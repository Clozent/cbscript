dir "C:\Users\Seth\AppData\Roaming\.minecraft 1.20\saves\Physics - One Wall"
desc "Automatically mine the blocks in front of you"
scale 1000

import common
import transforms
import math
import click_detector

define @ChainLink = @Entity[type=block_display,tag=chain]
    create {block_state:{Name:"minecraft:stone",Count:0b}, transformation:[0.2f,0f,0f,-0.1f,0f,0.2f,0f,-0.1f,0f,0f,0.2f,-0.1f,0f,0f,0f,1f],Tags:["chain"]}
end

reset
    for $row in $range(3)
        for $col in $range(3)
            /scoreboard objectives add m_$row$col dummy
        end
    end

    /kill @PhysicsBlock
    /summon minecraft:block_display 6.5 57.5 1.5 {block_state:{Name:"minecraft:grass_block",Count:0b}, interpolation_duration: 1b, Tags:["physics_block"]}

    /kill @Position
    create @Position
    
    as @PhysicsBlock
        @s.initialize_transform()
        @s.set_transform()
        @s.set_size(3000)
        @s.inv_mass = 400
        @s.inv_rot_int = 300
        angle = 0
    end
    
    click_detector_reset()
    as @Player
        create_click()
    end
    
    for i = 1 to 10
        /execute store result storage transform_test:global args.i int 1 run scoreboard players get Global i
        with
            $(i) = i
            $(word) = "test"
        macro_test()
    end
end

function macro_test()
    define name v = "v_$(i)"

    if i == 1
        /say $(word)
    end

    
    for k = 0 to i by i
        v.x = i
        v.y = k * 2
        
        if i%2 == 0
            v.x = -i
            v.y = -i * 2
        end
    end
    
    if k % 2 == 0
        k++
        k++
    end
    
    j = 0
    while j < i
        j += i
        v.z = j
    end
end

define @nearest_player = @Player[sort=nearest,limit=1]
end

clock tick
    as @Player at @s eyes
        /tp @Position ^ ^ ^
        world_eye_x = @Position.x
        world_eye_y = @Position.y
        world_eye_z = @Position.z
        
        /tp @Position ^ ^ ^1
        world_eye_dx = @Position.x - world_eye_x
        world_eye_dy = @Position.y - world_eye_y
        world_eye_dz = @Position.z - world_eye_z
        
        clicked = check_clicked()
    end
    click_detector_tick()

    as @PhysicsBlock
        if clicked
            @s.ray_intersection(world_eye_x, world_eye_y, world_eye_z, world_eye_dx, world_eye_dy, world_eye_dz)
            
            if @s.collision
                @Position.<pos> = <@s.collision_x, @s.collision_y, @s.collision_z>
                @Position.<pos> += <@s.collision_nx, @s.collision_ny, @s.collision_nz> / 8

                $PunchPower = 750

                @s.apply_impulse(@s.collision_x, @s.collision_y, @s.collision_z, world_eye_dx * $PunchPower / scale, world_eye_dy * $PunchPower / scale, world_eye_dz * $PunchPower / scale)
                
                at @Position
                    /particle minecraft:crit ~ ~ ~ 0 0 0 0 1 force
                end
            else
                #@s.glowing = 0
                
                #@s.clear_rotation()
            end
        end
        
        # Apply Gravity
        $Gravity = 5
        @s.velocity_y -= $Gravity

        @s.integrate()
        @s.quaternion_to_transform()
        
        max_penetration = 0
        
        for iter = 1 to 4
            max_col_v = 0
            
            halfsize = @s.size / 2
            
            for px = -halfsize to halfsize by @s.size
                for py = -halfsize to halfsize by @s.size
                    for pz = -halfsize to halfsize by @s.size
                        @s.local_to_world(px, py, pz, True)
                        
                        penetration = 56000 - world_y
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if -vel_y > max_col_v
                                max_col_v = -vel_y
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = 0
                                norm_y = scale
                                norm_z = 0
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = 0
                                max_pen_norm_y = scale
                                max_pen_norm_z = 0
                            end
                        end
                        
                        penetration = world_x - 10000
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if vel_x > max_col_v
                                max_col_v = vel_x
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = -scale
                                norm_y = 0
                                norm_z = 0
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = -scale
                                max_pen_norm_y = 0
                                max_pen_norm_z = 0
                            end
                        end
                        
                        penetration = world_z - 10000
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if vel_z > max_col_v
                                max_col_v = vel_z
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = 0
                                norm_y = 0
                                norm_z = -scale
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = 0
                                max_pen_norm_y = 0
                                max_pen_norm_z = -scale
                            end
                        end
                    end
                end
            end
            
            if max_col_v > 1
                collider1.x = @s.x
                collider1.y = @s.y
                collider1.z = @s.z
                
                collider1.velocity_x = @s.velocity_x
                collider1.velocity_y = @s.velocity_y
                collider1.velocity_z = @s.velocity_z
                
                collider1.rotation_x = @s.rotation_x
                collider1.rotation_y = @s.rotation_y
                collider1.rotation_z = @s.rotation_z

                collider1.inv_mass = @s.inv_mass
                collider1.inv_rot_int = @s.inv_rot_int
                
                collision1.norm_x = norm_x
                collision1.norm_y = norm_y
                collision1.norm_z = norm_z

                collision1.pen_x = pen_x
                collision1.pen_y = pen_y
                collision1.pen_z = pen_z
                
                /data merge storage transform_test:global {args:{collider1:1,collision:1}}
                /function $namespace:handle_collision_1body with storage $namespace:global args
                
                @s.apply_impulse(pen_x, pen_y, pen_z, collider1.ix, collider1.iy, collider1.iz)
            end
        end
        if max_penetration > 0
            @s.x += max_penetration * max_pen_norm_x / scale
            @s.y += max_penetration * max_pen_norm_y / scale
            @s.z += max_penetration * max_pen_norm_z / scale
        end
        
        @s.center_transform()
        @s.set_transform()
    end
end

function get_unused_collision_id()
    # TODO: Iterate through collision ids until an unallocated collision is found
end

# Assumes $(collision) contains the collision id
function store_collision()
    # If the collision id isn't in the global collision list, allocate it
    /$execute if score collision_$(collision) allocated < c1 Constant run function allocate_collision with $namespace:global args
    /$execute store result score c1 dx run scoreboard players get collision_$(collision) c1dx
end

function allocate_collision()
    /$scoreboard players set Global collision $(i)
    /$scoreboard players set collision_$(i) allocated 1
    # Add collision to list
    /execute store result storage $namespace:global contacts[-1] int 1 run scoreboard players get Global collision
    # TODO: Set the variable for the object-feature pair
end

function deallocate_collision()
    /$scoreboard players set collision_$(i) allocated 0
    # TODO: Remove collision from list
    # TODO: Clear the variable for the object-feature pair
end

# Checks if an object-feature collision pair exists
function collision_exists()

end

# Removes the last element of contacts and appends it to contacts_processed
# Returns the collision id, or -1 if there aren't any more collisions
function get_next_collision()
    contact = -1
    /execute store result score Global contact run data get storage $namespace:global contacts[-1]
    if contact >= 0
        /execute store result storage $namespace:global contacts_processed[-1] int 1 run scoreboard players get Global contact
    end
    
    return contact
end

function reset_collision_list()
    /data modify storage $namespace:global contacts set from storage $namespace:global contacts_processed
end

# Assumes $(collider) contains the collider id.
function create_collider(x, y, z)
    /$execute store result score collider_$(collider) x run scoreboard players get Global x
    /$execute store result score collider_$(collider) x run scoreboard players get Global y
    /$execute store result score collider_$(collider) x run scoreboard players get Global z
    
end
