dir "C:\Users\Seth\AppData\Roaming\.minecraft 1.20\saves\Physics - One Wall"
desc "Automatically mine the blocks in front of you"
scale 1000

import common
import transforms
import math
import click_detector

define @ChainLink = @Entity[type=block_display,tag=chain]
    create {block_state:{Name:"minecraft:stone",Count:0b}, transformation:[0.2f,0f,0f,-0.1f,0f,0.2f,0f,-0.1f,0f,0f,0.2f,-0.1f,0f,0f,0f,1f],Tags:["chain"]}
end

reset
    /kill @PhysicsBlock
    /summon minecraft:block_display 6.5 57.5 1.5 {block_state:{Name:"minecraft:grass_block",Count:0b}, interpolation_duration: 1b, Tags:["physics_block"]}

    /kill @Position
    create @Position
    
    as @PhysicsBlock
        @s.initialize_transform()
        @s.set_transform()
        @s.set_size(3000)
        @s.inv_mass = 400
        @s.inv_rot_int = 300
        angle = 0
    end
    
    click_detector_reset()
    as @Player
        create_click()
    end
end

define @nearest_player = @Player[sort=nearest,limit=1]
end

clock tick
    as @Player at @s eyes
        /tp @Position ^ ^ ^
        world_eye_x = @Position.x
        world_eye_y = @Position.y
        world_eye_z = @Position.z
        
        /tp @Position ^ ^ ^1
        world_eye_dx = @Position.x - world_eye_x
        world_eye_dy = @Position.y - world_eye_y
        world_eye_dz = @Position.z - world_eye_z
        
        clicked = check_clicked()
    end
    click_detector_tick()

    as @PhysicsBlock
        if clicked
            @s.ray_intersection(world_eye_x, world_eye_y, world_eye_z, world_eye_dx, world_eye_dy, world_eye_dz)
            
            if @s.collision
                @Position.<pos> = <@s.collision_x, @s.collision_y, @s.collision_z>
                @Position.<pos> += <@s.collision_nx, @s.collision_ny, @s.collision_nz> / 8

                $PunchPower = 750

                @s.apply_impulse(@s.collision_x, @s.collision_y, @s.collision_z, world_eye_dx * $PunchPower / scale, world_eye_dy * $PunchPower / scale, world_eye_dz * $PunchPower / scale)
                
                at @Position
                    /particle minecraft:crit ~ ~ ~ 0 0 0 0 1 force
                end
            else
                #@s.glowing = 0
                
                #@s.clear_rotation()
            end
        end
        
        # Apply Gravity
        $Gravity = 5
        @s.velocity_y -= $Gravity

        @s.integrate()
        @s.quaternion_to_transform()
        
        max_penetration = 0
        
        for iter = 1 to 4
            max_col_v = 0
            
            halfsize = @s.size / 2
            
            for px = -halfsize to halfsize by @s.size
                for py = -halfsize to halfsize by @s.size
                    for pz = -halfsize to halfsize by @s.size
                        @s.local_to_world(px, py, pz, True)
                        
                        penetration = 56000 - world_y
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if -vel_y > max_col_v
                                max_col_v = -vel_y
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = 0
                                norm_y = scale
                                norm_z = 0
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = norm_x
                                max_pen_norm_y = norm_y
                                max_pen_norm_z = norm_z
                            end
                        end
                        
                        penetration = world_x - 10000
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if vel_x > max_col_v
                                max_col_v = vel_x
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = -scale
                                norm_y = 0
                                norm_z = 0
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = norm_x
                                max_pen_norm_y = norm_y
                                max_pen_norm_z = norm_z
                            end
                        end
                        
                        penetration = world_z - 10000
                        
                        if penetration > 0
                            dx = world_x - @s.x
                            dy = world_y - @s.y
                            dz = world_z - @s.z
                        
                            rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                            rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                            rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                            
                            vel_x = @s.velocity_x + rot_lin_vel_x
                            vel_y = @s.velocity_y + rot_lin_vel_y
                            vel_z = @s.velocity_z + rot_lin_vel_z
                            
                            if vel_z > max_col_v
                                max_col_v = vel_z
                                pen_x = world_x
                                pen_y = world_y
                                pen_z = world_z
                                
                                norm_x = 0
                                norm_y = 0
                                norm_z = -scale
                            end
                            if penetration > max_penetration
                                max_penetration = penetration
                                max_pen_norm_x = norm_x
                                max_pen_norm_y = norm_y
                                max_pen_norm_z = norm_z
                            end
                        end
                    end
                end
            end
            
            if max_col_v > 1
                # Create contact basis/transform
                ct_01 = norm_x
                ct_11 = norm_y
                ct_21 = norm_z
                
                absx = abs(norm_x)
                absz = abs(norm_z)
                
                if absx < absz
                    # The norm isn't pointing toward x, so
                    # cross the norm with 1,0,0
                    s = sqrt(norm_y*norm_y + norm_z*norm_z)
                    ct_00 = 0
                    ct_10 = -norm_z * scale / s
                    ct_20 = norm_y * scale / s

                    # Cross the norm with the new vector
                    ct_02 = (ct_10*ct_21 - ct_20*ct_11 + 500) / scale
                    ct_12 = (ct_20*ct_01 + 500) / scale
                    ct_22 = (ct_10*ct_01 + 500) / scale
                else
                    # The norm isn't pointing toward z, so
                    # cross the norm with 0,0,1
                    s = sqrt(norm_y*norm_y + norm_x*norm_x)
                    ct_00 = norm_y * scale / s
                    ct_10 = -norm_x * scale / s
                    ct_20 = 0

                    # Cross the norm with the new vector
                    ct_02 = (ct_10*ct_21 + 500) / scale
                    ct_12 = (ct_00*ct_21 + 500) / scale
                    ct_22 = (ct_00*ct_11 - ct_10*ct_01 + 500) / scale
                end
                
                # Full cross product would be:
                #ct_20 = (ct_10*ct_21 - ct_20*ct_11 + 500) / scale
                #ct_21 = (ct_20*ct_01 - ct_00*ct_21 + 500) / scale
                #ct_22 = (ct_00*ct_11 - ct_10*ct_01 + 500) / scale

                
                dx = pen_x - @s.x
                dy = pen_y - @s.y
                dz = pen_z - @s.z
                
                rot_lin_vel_x = (@s.rotation_y * dz - @s.rotation_z * dy + 500) / scale
                rot_lin_vel_y = (@s.rotation_z * dx - @s.rotation_x * dz + 500) / scale
                rot_lin_vel_z = (@s.rotation_x * dy - @s.rotation_y * dx + 500) / scale
                
                w_vel_x = @s.velocity_x + rot_lin_vel_x
                w_vel_y = @s.velocity_y + rot_lin_vel_y
                w_vel_z = @s.velocity_z + rot_lin_vel_z
                
                # Transform by the ct transpose matrix to get contact coordinates
                c_vel_x = (ct_00 * w_vel_x + ct_10 * w_vel_y + ct_20 * w_vel_z + 500) / scale
                c_vel_y = (ct_01 * w_vel_x + ct_11 * w_vel_y + ct_21 * w_vel_z + 500) / scale
                c_vel_z = (ct_02 * w_vel_x + ct_12 * w_vel_y + ct_22 * w_vel_z + 500) / scale

                # Impulse to torque skew symmetric matrix
                #i_to_t_00 = 0
                #i_to_t_01 = -dz
                #i_to_t_02 = dy
                     
                #i_to_t_10 = dz
                #i_to_t_11 = 0
                #i_to_t_12 = -dx
                     
                #i_to_t_20 = -dy
                #i_to_t_21 = dx
                #i_to_t_22 = 0
                
                # Impulse to velocity transform
                # Formula: -(i_to_t^2) * InverseRotationalIntertia
                i_to_v_00 = ((dz * dz + dy * dy + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_01 = ((-dy * dx + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_02 = ((-dz * dx + 500) / scale * @s.inv_rot_int + 500) / scale

                i_to_v_10 = ((-dx * dy + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_11 = ((dz * dz + dx * dx + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_12 = ((-dz * dy + 500) / scale * @s.inv_rot_int + 500) / scale

                i_to_v_20 = ((-dx * dz + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_21 = ((-dy * dz + 500) / scale * @s.inv_rot_int + 500) / scale
                i_to_v_22 = ((dy * dy + dx * dx + 500) / scale * @s.inv_rot_int + 500) / scale
                
                i_to_v_00 += @s.inv_mass
                i_to_v_11 += @s.inv_mass
                i_to_v_22 += @s.inv_mass
                
                # Transform i_to_v into contact coordinates before inverting,
                # using change of basis formula
                
                # First, ct^transpose * i_to_v
                /data merge storage $namespace:global {args:{m1:"ct",m2:"i_to_v",out:"m"}}
                /function $namespace:transpose_matrix_multiply with storage $namespace:global args

                # Then, multiply by ct
                /data merge storage $namespace:global {args:{m1:"m",m2:"ct",out:"c_i_to_v"}}
                /function $namespace:matrix_multiply with storage $namespace:global args
                
                a = c_i_to_v_00
                b = c_i_to_v_01
                c = c_i_to_v_02
                
                d = c_i_to_v_10
                e = c_i_to_v_11
                f = c_i_to_v_12
                
                g = c_i_to_v_20
                h = c_i_to_v_21
                i = c_i_to_v_22
                
                # Inverse impulse to velocity
                det = ((a * e + 500) / scale * i + (d * h + 500) / scale * c + (g * b + 500) / scale * f - (a * h + 500) / scale * f - (g * e + 500) / scale * c - (d * b + 500) / scale * i + 500) / scale

                v_to_i_00 = (e * i - f * h) / det
                v_to_i_01 = (c * h - b * i) / det
                v_to_i_02 = (b * f - c * e) / det

                v_to_i_10 = (f * g - d * i) / det
                v_to_i_11 = (a * i - c * g) / det
                v_to_i_12 = (c * d - a * f) / det
                
                v_to_i_20 = (d * h - e * g) / det
                v_to_i_21 = (b * g - a * h) / det
                v_to_i_22 = (a * e - b * d) / det
                
                $Restitution = 200
                restitution = $Restitution
                if c_vel_y > -5 * $Gravity
                    restitution = 0
                end
                
                desired_vx = 0
                # TODO: Add gravity in the positive Y world direction
                desired_vy = (-(c_vel_y) * restitution + 500) / scale
                desired_vz = 0

                desired_dvx = desired_vx - c_vel_x
                desired_dvy = desired_vy - c_vel_y
                desired_dvz = desired_vz - c_vel_z
                
                cix = (v_to_i_00 * desired_dvx + v_to_i_01 * desired_dvy + v_to_i_02 * desired_dvz + 500) / scale
                ciy = (v_to_i_10 * desired_dvx + v_to_i_11 * desired_dvy + v_to_i_12 * desired_dvz + 500) / scale
                ciz = (v_to_i_20 * desired_dvx + v_to_i_21 * desired_dvy + v_to_i_22 * desired_dvz + 500) / scale
                
                planar_impulse = sqrt(cix*cix + ciz*ciz)
                
                $Friction = 800
                max_fric_impulse = (ciy * $Friction + 500) / scale
                
                if planar_impulse > max_fric_impulse
                    dir_ix = cix * scale / planar_impulse
                    dir_iz = ciz * scale / planar_impulse
                
                    v_per_i_y = c_i_to_v_11 + ((c_i_to_v_10 * dir_ix + c_i_to_v_12 * dir_iz + 500) / scale * $Friction + 500) / scale
                    
                    ciy = desired_dvy * scale / v_per_i_y
                    
                    cix = ((dir_ix * $Friction + 500) / scale * ciy + 500) / scale
                    ciz = ((dir_iz * $Friction + 500) / scale * ciy + 500) / scale
                end
                
                # Transform impulse vector out of contact coordinates
                ix = (ct_00 * cix + ct_01 * ciy + ct_02 * ciz + 500) / scale
                iy = (ct_10 * cix + ct_11 * ciy + ct_12 * ciz + 500) / scale
                iz = (ct_20 * cix + ct_21 * ciy + ct_22 * ciz + 500) / scale
                
                @s.apply_impulse(pen_x, pen_y, pen_z, ix, iy, iz)
            end
        end
        if max_penetration > 0
            @s.x += max_penetration * max_pen_norm_x / scale
            @s.y += max_penetration * max_pen_norm_y / scale
            @s.z += max_penetration * max_pen_norm_z / scale
        end
        
        @s.center_transform()
        @s.set_transform()
    end
end
