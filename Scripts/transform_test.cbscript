dir "C:\Users\Seth\AppData\Roaming\.minecraft 1.20\saves\Physics - One Wall"
desc "Automatically mine the blocks in front of you"
scale 1000

import common
import transforms
import math
import click_detector

define @ChainLink = @Entity[type=block_display,tag=chain]
    create {block_state:{Name:"minecraft:stone",Count:0b}, transformation:[0.2f,0f,0f,-0.1f,0f,0.2f,0f,-0.1f,0f,0f,0.2f,-0.1f,0f,0f,0f,1f],Tags:["chain"]}
end

$Precision = 1000
$NumCubes = 1

reset
    for $row in $range(3)
        for $col in $range(3)
            /scoreboard objectives add m_$row$col dummy
        end
    end

    /kill @PhysicsBlock
    
    with
        $(collider) = 1
    create_collider(6500, 57500, 1500, 3000, 400, 300)
    
    #with
    #    $(collider) = 2
    #create_collider(1500, 57500, 1500, 1000, 800, 600)

    #with
    #    $(collider) = 3
    #create_collider(-2500, 57500, 1500, 2000, 600, 400)

    #with
    #    $(collider) = 4
    #create_collider(-7500, 57500, 1500, 6000, 200, 200)
    

    /kill @Position
    create @Position
    
    click_detector_reset()
    as @Player
        create_click()
    end
    
    # Point 1 starts at origin and goes in positive x
    # Point 2 starts at -0.5, -1.5, -0.5 and goes in positive x and positive y
    get_edge_edge_penetration(0, 0, 0, 1000, 0, 0, -1500, -500, -500, 707, 707, 0)
    
    tell @a "norm: (nx), (ny), (nz)"
    tell @a "dist: (d)"
    tell @a "pen point 2: (p1x), (p1y), (p1z)"
end

function get_edge_edge_penetration(o1x, o1y, o1z, d1x, d1y, d1z, o2x, o2y, o2z, d2x, d2y, d2z)
    # Cross the two directions to get the normal
    nx = (d1y * d2z - d1z * d2y) / $Precision
    ny = (d1z * d2x - d1x * d2z) / $Precision
    nz = (d1x * d2y - d1y * d2x) / $Precision

    # Get the magnitude and square magnitude
    nmagsq = nx*nx + ny*ny + nz*nz
    nmag = sqrt(nmagsq)
    
    # Difference of origins
    odx = o2x - o1x
    ody = o2y - o1y
    odz = o2z - o1z

    # Get the distance
    d = (nx * odx + ny * ody + nz * odz) / nmag
    
    # Get a vector perpendicular to the normal and the second ray
    # These are scaled up by the Precision because it'll be divided
    # out in the next step
    perpx_big = d2y * nz - d2z * ny
    perpy_big = d2z * nx - d2x * nz
    perpz_big = d2x * ny - d2y * nx
    
    # Get the projected distance along the first ray
    t = (perpx_big * odx + perpy_big * ody + perpz_big * odz) / nmagsq
    
    # Get the point on the first ray
    p1x = o1x + t * d1x / $Precision
    p1y = o1y + t * d1y / $Precision
    p1z = o1z + t * d1z / $Precision

    # Normalize the normal
    nx *= $Precision
    ny *= $Precision
    nz *= $Precision
    nx /= nmag
    ny /= nmag
    nz /= nmag
end

define @nearest_player = @Player[sort=nearest,limit=1]
end

clock tick
    define name collider = "collider_$(collider)"

    as @Player at @s eyes
        /tp @Position ^ ^ ^
        world_eye_x = @Position.x
        world_eye_y = @Position.y
        world_eye_z = @Position.z
        
        /tp @Position ^ ^ ^1
        world_eye_dx = @Position.x - world_eye_x
        world_eye_dy = @Position.y - world_eye_y
        world_eye_dz = @Position.z - world_eye_z
        
        clicked = check_clicked()
    end
    click_detector_tick()
    
    delete_collisions()

    for collider = 1 to $NumCubes
        with
            $(collider) = collider
        do
            if not collider.sleeping
                collider_physics_tick() with macros
            end
        end
    end
    
    for collider = 1 to $NumCubes
        with
            $(collider) = collider
        do
            collider_check_clicked() with macros
            
            if not collider.sleeping
                get_collisions() with macros
            end
            
            get_edge_world_collisions() with macros
        end
    end
    
    resolve_collision_velocity()
    resolve_collision_penetration()
    
    for collider = 1 to $NumCubes
        with
            $(collider) = collider
        do
            if not collider.sleeping
                collider_set_transform() with macros
                collider_check_sleep() with macros
            end
        end
    end
end

function collider_check_clicked()
    define name collider = "collider_$(collider)"

    if clicked
        if collider_ray_intersection(world_eye_x, world_eye_y, world_eye_z, world_eye_dx, world_eye_dy, world_eye_dz) with macros
            @Position.<pos> = <collision_x, collision_y, collision_z>
            @Position.<pos> += <collision_nx, collision_ny, collision_nz> / 8

            $PunchPower = 1000

            collider_apply_impulse(collision_x, collision_y, collision_z, world_eye_dx * $PunchPower / scale, world_eye_dy * $PunchPower / scale, world_eye_dz * $PunchPower / scale) with macros
            
            at @Position
                /particle minecraft:crit ~ ~ ~ 0 0 0 0 1 force
            end
        end
    end
end

function collider_physics_tick()
    define name collider = "collider_$(collider)"
    
    # Apply Gravity
    $Gravity = 45
    collider.velocity_y -= $Gravity
    
    collider_integrate() with macros
    collider_quaternion_to_transform() with macros
end

function resolve_collision_velocity()
    for vel_iter = 1 to 10
        max_closing = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"
            
                if collision.exists
                    with
                        $(collider1) = collision.collider1
                    update_closing_velocity()
                    
                    if collision.closing > max_closing
                        max_closing = collision.closing
                        max_closing_id = collision.id
                        max_closing_col1 = collision.collider1
                        max_closing_col2 = collision.collider2
                    end
                end
            end
        end
        
        if max_closing <= 5
            vel_iter = 1000000
        else
            with
                $(collision) = max_closing_id
                $(collider1) = max_closing_col1
                $(collider2) = max_closing_col2
            handle_collision_1body()
        end
    end
end

function update_closing_velocity()
    define name collision = "collision_$(collision)"
    define name collider1 = "collider_$(collider1)"
    
    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z

    rot_lin_vel_x = (collider1.rotation_y * dz - collider1.rotation_z * dy + 500) / $Precision
    rot_lin_vel_y = (collider1.rotation_z * dx - collider1.rotation_x * dz + 500) / $Precision
    rot_lin_vel_z = (collider1.rotation_x * dy - collider1.rotation_y * dx + 500) / $Precision
    
    collision.vel_x = collider1.velocity_x + rot_lin_vel_x
    collision.vel_y = collider1.velocity_y + rot_lin_vel_y
    collision.vel_z = collider1.velocity_z + rot_lin_vel_z

    collision.closing = -(collision.vel_x * collision.nx + collision.vel_y * collision.ny + collision.vel_z * collision.nz + 500) / $Precision
end

function resolve_collision_penetration()
    for pen_iter = 1 to 10
        max_pen = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"

                if collision.exists and collision.pen > max_pen
                    max_pen = collision.pen
                    max_pen_nx = collision.nx
                    max_pen_ny = collision.ny
                    max_pen_nz = collision.nz
                    max_pen_col1 = collision.collider1
                    max_pen_col2 = collision.collider2
                end
            end
        end
        
        if max_pen <= 5
            pen_iter = 1000000
        else
            mx = (max_pen_nx * max_pen + 500) / $Precision
            my = (max_pen_ny * max_pen + 500) / $Precision
            mz = (max_pen_nz * max_pen + 500) / $Precision
            
            with
                $(collider) = max_pen_col1
            do
                define name collider = "collider_$(collider)"
    
                collider.x += mx
                collider.y += my
                collider.z += mz
            end
            
            move_collisions(mx, my, mz)
        end
    end
end

function move_collisions(dx, dy, dz)
    for collision = 1 to max_collision
        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
    
            # TODO: Make this move the right direction depending on which collider matches
            if collision.exists
                do_move = False
                if collision.collider1 == max_pen_col1
                    do_move = True
                end
                if collision.collider1 == max_pen_col2
                    do_move = True
                end
                if max_pen_col2 >= 0
                    if collision.collider2 == max_pen_col1
                        do_move = True
                    end
                    if collision.collider2 == max_pen_col2
                        do_move = True
                    end
                end
                
                if do_move
                    collision.pen -= (dx*collision.nx + dy*collision.ny + dz*collision.nz + 500) / $Precision
                end
            end
        end
    end
end

function get_collisions()
    define name collider = "collider_$(collider)"
    halfsize = collider.size / 2
    
    collider_calculate_vertex_world_positions() with macros

    for vertex = 0 to 7
        with
            $(vertex) = vertex
        do
            define name v = "collider_$(collider)_v$(vertex)"
            
            @Position.<pos> = <v.x, v.y, v.z>
            at @Position
                unless block ~ ~ ~ air
                    block_x = v.x % $Precision
                    block_y = v.y % $Precision
                    block_z = v.z % $Precision
                    
                    min_pen = 1000
                    
                    if block ~1 ~ ~ air
                        pen = $Precision - block_x
                        if pen < min_pen
                            min_pen = pen
                            nx = $Precision
                            ny = 0
                            nz = 0
                        end
                    end
                    
                    if block ~ ~1 ~ air
                        pen = $Precision - block_y
                        if pen < min_pen
                            min_pen = pen
                            nx = 0
                            ny = $Precision
                            nz = 0
                        end
                    end
                    
                    if block ~ ~ ~1 air
                        pen = $Precision - block_z
                        if pen < min_pen
                            min_pen = pen
                            nx = 0
                            ny = 0
                            nz = $Precision
                        end
                    end
                    
                    if block ~-1 ~ ~ air
                        pen = block_x
                        if pen < min_pen
                            min_pen = pen
                            nx = -$Precision
                            ny = 0
                            nz = 0
                        end
                    end
                    
                    if block ~ ~-1 ~ air
                        pen = block_y
                        if pen < min_pen
                            min_pen = pen
                            nx = 0
                            ny = -$Precision
                            nz = 0
                        end
                    end
                    
                    if block ~ ~ ~-1 air
                        pen = block_z
                        if pen < min_pen
                            min_pen = pen
                            nx = 0
                            ny = 0
                            nz = -$Precision
                        end
                    end
                    
                    if min_pen < 1000
                        create_collision(v.x, v.y, v.z, nx, ny, nz, min_pen, collider.id, -1)
                    end
                end
            end
        end
    end
    
    # Check each world geometry block corner to see if there's a block there,
    # and if so, whether it collides.
    start_x = (collider.min_x/$Precision+1)*$Precision
    start_y = (collider.min_y/$Precision+1)*$Precision
    start_z = (collider.min_z/$Precision+1)*$Precision
    
    for block_x = start_x to collider.max_x by $Precision
        for block_y = start_y to collider.max_y by $Precision
            for block_z = start_z to collider.max_z by $Precision
                @Position.<pos> = <block_x, block_y, block_z>
                at @Position
                    if block ~ ~ ~ air and block ~ ~ ~-1 air and block ~ ~-1 ~ air and block ~ ~-1 ~-1 air and block ~-1 ~ ~ air and block ~-1 ~ ~-1 air and block ~-1 ~-1 ~ air and block ~-1 ~-1 ~-1 air
                    
                    else
                        collider_world_to_local(block_x, block_y, block_z, True) with macros
                        if local_x > -halfsize and local_x < halfsize and local_y > -halfsize and local_y < halfsize and local_z > -halfsize and local_z < halfsize
                            min_pen = halfsize
                            
                            pen = halfsize + local_x
                            if pen < min_pen
                                min_pen = pen
                                lnx = $Precision
                                lny = 0
                                lnz = 0
                            end
                            
                            pen = halfsize - local_x
                            if pen < min_pen
                                min_pen = pen
                                lnx = -$Precision
                                lny = 0
                                lnz = 0
                            end
                            
                            pen = halfsize + local_y
                            if pen < min_pen
                                min_pen = pen
                                lnx = 0
                                lny = $Precision
                                lnz = 0
                            end
                            
                            pen = halfsize - local_y
                            if pen < min_pen
                                min_pen = pen
                                lnx = 0
                                lny = -$Precision
                                lnz = 0
                            end
                            
                            pen = halfsize + local_z
                            if pen < min_pen
                                min_pen = pen
                                lnx = 0
                                lny = 0
                                lnz = $Precision
                            end
                            
                            pen = halfsize - local_z
                            if pen < min_pen
                                min_pen = pen
                                lnx = 0
                                lny = 0
                                lnz = -$Precision
                            end

                            if min_pen < halfsize
                                collider_local_to_world(lnx, lny, lnz, False) with macros
                                
                                create_collision(block_x, block_y, block_z, world_x, world_y, world_z, min_pen, collider.id, -1)
                            end
                        end
                    end
                end
            end
        end
    end
end

function get_edge_world_collisions()
    define name collider = "collider_$(collider)"
    
    for $edge in [[0, 2], [1, 3], [0, 4], [1, 5], [2, 6], [3, 7], [4, 6], [5, 7], [0, 7], [2, 5], [4, 3], [6, 1]]
        $vertex1 = $edge[0]
        $vertex2 = $edge[1]
        with
            $(vertex) = $vertex1
        do
            define name v = "collider_$(collider)_v$(vertex)"
            ox = v.x
            oy = v.y
            oz = v.z
        end
        
        with
            $(vertex) = $vertex2
        do
            define name v = "collider_$(collider)_v$(vertex)"
            destx = v.x
            desty = v.y
            destz = v.z
        end
        
        ex = (destx - ox) * $Precision / collider.size
        ey = (desty - oy) * $Precision / collider.size
        ez = (destz - oz) * $Precision / collider.size
        
        if ex == 0
            ex = 1
        end
        if ey == 0
            ey = 1
        end
        if ez == 0
            ez = 1
        end
        
        t = 0
        x = ox
        y = oy
        z = oz
        
        
        if ex < 0
            next_x = x / $Precision * $Precision
        else
            next_x = (x / $Precision + 1) * $Precision
        end
        if ey < 0
            next_y = y / $Precision * $Precision
        else
            next_y = (y / $Precision + 1) * $Precision
        end
        if ez < 0
            next_z = z / $Precision * $Precision
        else
            next_z = (z / $Precision + 1) * $Precision
        end
        
        failsafe = 0
        while t < collider.size and failsafe < 50
            failsafe++
            next_x_t = (next_x - ox) * $Precision / ex
            next_y_t = (next_y - oy) * $Precision / ey
            next_z_t = (next_z - oz) * $Precision / ez
            
            if next_x_t < next_y_t and next_x_t < next_z_t
                # Crosses at x next
                t = next_x_t
                
                if ex < 0
                    next_x -= $Precision
                else
                    next_x += $Precision
                end
                
                next_x_t = (next_x - ox) * $Precision / ex
            else if next_y_t < next_z_t
                # Crosses at y next
                t = next_y_t
                
                if ey < 0
                    next_y -= $Precision
                else
                    next_y += $Precision
                end
                
                next_y_t = (next_y - oy) * $Precision / ey
            else
                # Crosses at z next
                t = next_z_t
                
                if ez < 0
                    next_z -= $Precision
                else
                    next_z += $Precision
                end
                
                next_z_t = (next_z - oz) * $Precision / ez
            end
            
            if t < collider.size            
                x = ox + t * ex / $Precision
                y = oy + t * ey / $Precision
                z = oz + t * ez / $Precision
            
                @Position.<pos> = <x, y, z>
                at @Position
                    /particle minecraft:bubble_pop ~ ~ ~ 0 0 0 0 1 force
                end
            end
        end
    end
end

function create_collision(x, y, z, nx, ny, nz, pen, collider1, collider2)
    id = get_unused_collision_id()

    with
        $(collision) = id
    do
        define name collision = "collision_$(collision)"
        
        /scoreboard players set collision_$(collision) id $(collision)
        collision.exists = True
        collision.x = x
        collision.y = y
        collision.z = z
        
        collision.nx = nx
        collision.ny = ny
        collision.nz = nz
        
        collision.pen = pen
        
        collision.collider1 = collider1
        collision.collider2 = collider2
        
        if collision.id > max_collision
            max_collision = collision.id
        end    
    end
end

function get_unused_collision_id()
    unused_id = -1

    for collision = collision_start to 200
        exists = False

        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            exists = collision.exists
        end
        
        if not exists
            collision_start = collision + 1
            unused_id = collision
            collision = 1000000
        end
    end
    
    return unused_id
end

function delete_collisions()
    for collision = 1 to max_collision
        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            if collision.exists
                if collision.id < collision_start
                    collision_start = collision.id
                end

                /scoreboard players reset collision_$(collision)
            end
        end        
        
    end
    
    max_collision = 0
    collision_start = 1
end