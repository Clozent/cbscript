import common
import math

$InverseMass = 500
$InverseRotationalIntertia = 500
$Precision = 1000
$Half = 500
$CancelRestitution = -100

define @PhysicsBlock = @Entity[type=block_display,tag=physics_block]

end


# These lines register the variables for the matrix_multiply functions
# It doesn't actually need to be called.
function register_transform_variables()
    accum = 0
end

function quaternion_multiply(w1, i1, j1, k1, w2, i2, j2, k2)
    new_w = (w1*w2 - i1*i2 - j1*j2 - k1*k2 + $Half) / $Precision
    new_i = (w1*i2 + i1*w2 + j1*k2 - k1*j2 + $Half) / $Precision
    new_j = (w1*j2 - i1*k2 + j1*w2 + k1*i2 + $Half) / $Precision
    new_k = (w1*k2 + i1*j2 - j1*i2 + k1*w2 + $Half) / $Precision
end

# Assumes $namespace:global args contains
# $(m1) $(m2) and $(out), which contain the names of matrices, where a matrix
# has indexed values like m_00, m_01
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:matrix_multiply with storage $namespace:global args
function matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_$row0
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row1
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row2
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= c1000 Constant
        end
    end
end

# Transposes m1 before multiplying by m2
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:transpose_matrix_multiply with storage $namespace:global args
function transpose_matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_0$row
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_1$row
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_2$row
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= c1000 Constant
        end
    end
end

function create_collider(x, y, z, size, inv_mass, inv_rot_int)
    define name collider = "collider_$(collider)"
    
    /scoreboard players set collider_$(collider) id $(collider)
    
    collider.x = x
    collider.y = y
    collider.z = z
    collider.size = size
    collider.halfsize = size / 2
    collider.inv_mass = inv_mass
    collider.inv_rot_int = inv_rot_int
    
    collider.w = $Precision
    collider.i = 0
    collider.j = 0
    collider.k = 0
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider_wake_up() with macros
    
    collider_quaternion_to_transform() with macros

    /summon minecraft:block_display ~ ~ ~ {block_state:{Name:"minecraft:grass_block",Count:0b}, interpolation_duration: 1, teleport_duration: 1, Tags:["physics_block"]}
    @PhysicsBlock.age++
    as @PhysicsBlock[age == 1]
        /scoreboard players set @s collider_id $(collider)
        @s.x = x
        @s.y = y
        @s.z = z
    end
end

function collider_clear_velocity()
    define name collider = "collider_$(collider)"

    collider.velocity_x = 0
    collider.velocity_y = 0
    collider.velocity_z = 0
end

function collider_clear_rotation()
    define name collider = "collider_$(collider)"

    collider.rotation_x = 0
    collider.rotation_y = 0
    collider.rotation_z = 0
end

function collider_wake_up()
    define name collider = "collider_$(collider)"

    collider.recent_motion = 10000
    collider.recent_rotation = 10000
    collider.sleeping = False
end

function collider_sleep()
    define name collider = "collider_$(collider)"
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider.sleeping = True
end

function collider_check_sleep()
    define name collider = "collider_$(collider)"
    
    if collider.recent_motion < 2200 and collider.recent_rotation < 2200
        collider_sleep() with macros
    end
end

function collider_integrate()
    define name collider = "collider_$(collider)"
    
    collider_integrate_velocity() with macros
    collider_integrate_rotation() with macros
end

function collider_integrate_velocity()
    define name collider = "collider_$(collider)"
    
    collider.velocity_x = (collider.velocity_x * 980 + $Half) / $Precision
    collider.velocity_y = (collider.velocity_y * 980 + $Half) / $Precision
    collider.velocity_z = (collider.velocity_z * 980 + $Half) / $Precision
    
    collider.x += collider.velocity_x
    collider.y += collider.velocity_y
    collider.z += collider.velocity_z
    
    motion = (collider.velocity_x * collider.velocity_x + collider.velocity_y * collider.velocity_y + collider.velocity_z * collider.velocity_z) / 10
    collider.recent_motion *= 9
    collider.recent_motion /= 10
    collider.recent_motion += motion
end

function collider_integrate_rotation()
    define name collider = "collider_$(collider)"
    
    collider.rotation_x = (collider.rotation_x * 980 + $Half) / $Precision
    collider.rotation_y = (collider.rotation_y * 980 + $Half) / $Precision
    collider.rotation_z = (collider.rotation_z * 980 + $Half) / $Precision
    
    quaternion_multiply(0, collider.rotation_x, collider.rotation_y, collider.rotation_z, collider.w, collider.i, collider.j, collider.k)
    
    collider.w += new_w / 2
    collider.i += new_i / 2
    collider.j += new_j / 2
    collider.k += new_k / 2

    collider_normalize_quaternion() with macros

    rotation = (collider.rotation_x * collider.rotation_x + collider.rotation_y * collider.rotation_y + collider.rotation_z * collider.rotation_z) / 10
    collider.recent_rotation *= 9
    collider.recent_rotation /= 10
    collider.recent_rotation += motion
end

function collider_set_transform()
    define name collider = "collider_$(collider)"

    /data modify storage $namespace:global transformation set value [1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f]
    d00 = collider.t00 * collider.size / $Precision
    d01 = collider.t01 * collider.size / $Precision
    d02 = collider.t02 * collider.size / $Precision
    d10 = collider.t10 * collider.size / $Precision
    d11 = collider.t11 * collider.size / $Precision
    d12 = collider.t12 * collider.size / $Precision
    d20 = collider.t20 * collider.size / $Precision
    d21 = collider.t21 * collider.size / $Precision
    d22 = collider.t22 * collider.size / $Precision
    dx = (d00 + d01 + d02) / -2
    dy = (d10 + d11 + d12) / -2
    dz = (d20 + d21 + d22) / -2
    
    for $pair in [[0,"d00"], [1,"d01"], [2,"d02"], [3,"dx"], [4,"d10"], [5,"d11"], [6,"d12"], [7,"dy"], [8,"d20"], [9,"d21"], [10,"d22"], [11,"dz"]]
        $idx = $pair[0]
        $var = $pair[1]
        $downscale = 1.0 / $Precision
        /execute store result storage $namespace:global transformation[$idx] float $downscale run scoreboard players get Global $var
    end
    
    as @PhysicsBlock
        if @s.collider_id == collider.id
            @s.x = collider.x
            @s.y = collider.y
            @s.z = collider.z
            /data modify entity @s transformation set from storage transform_test:global transformation
            /data modify entity @s start_interpolation set value 0b
        end
    end
end

function collider_normalize_quaternion()
    define name collider = "collider_$(collider)"

    mag = sqrt(collider.w*collider.w + collider.i*collider.i + collider.j*collider.j + collider.k*collider.k)
    
    collider.w *= $Precision
    collider.w += $Half
    collider.w /= mag
    collider.i *= $Precision
    collider.i += $Half
    collider.i /= mag
    collider.j *= $Precision
    collider.j += $Half
    collider.j /= mag
    collider.k *= $Precision
    collider.k += $Half
    collider.k /= mag
end

function collider_multiply_quaternion_right(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(collider.w, collider.i, collider.j, collider.k, w, i, j, k)
    
    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_multiply_quaternion_left(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(w, i, j, k, collider.w, collider.i, collider.j, collider.k)

    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_quaternion_to_transform()
    define name collider = "collider_$(collider)"

    collider.t00 = $Precision - (2 * collider.j * collider.j) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t01 = (2 * collider.i * collider.j) / $Precision - (2 * collider.k * collider.w) / $Precision
    collider.t02 = (2 * collider.i * collider.k) / $Precision + (2 * collider.j * collider.w) / $Precision

    collider.t10 = (2 * collider.i * collider.j) / $Precision + (2 * collider.k * collider.w) / $Precision
    collider.t11 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t12 = (2 * collider.j * collider.k) / $Precision - (2 * collider.i * collider.w) / $Precision

    collider.t20 = (2 * collider.i * collider.k) / $Precision - (2 * collider.j * collider.w) / $Precision
    collider.t21 = (2 * collider.j * collider.k) / $Precision + (2 * collider.i * collider.w) / $Precision
    collider.t22 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.j * collider.j) / $Precision
end

function collider_local_to_world(x, y, z, translation)
    define name collider = "collider_$(collider)"

    world_x = (collider.t00 * x + collider.t01 * y + collider.t02 * z + $Half) / $Precision
    world_y = (collider.t10 * x + collider.t11 * y + collider.t12 * z + $Half) / $Precision
    world_z = (collider.t20 * x + collider.t21 * y + collider.t22 * z + $Half) / $Precision
    
    if translation
        world_x += collider.x
        world_y += collider.y
        world_z += collider.z
    end
end

function collider_world_to_local(x, y, z, translation)
    define name collider = "collider_$(collider)"

    if translation
        x -= collider.x
        y -= collider.y
        z -= collider.z
    end
    
    local_x = (collider.t00 * x + collider.t10 * y + collider.t20 * z + $Half) / $Precision
    local_y = (collider.t01 * x + collider.t11 * y + collider.t21 * z + $Half) / $Precision
    local_z = (collider.t02 * x + collider.t12 * y + collider.t22 * z + $Half) / $Precision
end

function collider_apply_impulse(x, y, z, ix, iy, iz)
    define name collider = "collider_$(collider)"
    
    collider.velocity_x += (ix * collider.inv_mass + $Half) / $Precision
    collider.velocity_y += (iy * collider.inv_mass + $Half) / $Precision
    collider.velocity_z += (iz * collider.inv_mass + $Half) / $Precision

    dx = x - collider.x
    dy = y - collider.y
    dz = z - collider.z
    
    axis_x = (dy * iz - dz * iy + $Half) / $Precision
    axis_y = (dz * ix - dx * iz + $Half) / $Precision
    axis_z = (dx * iy - dy * ix + $Half) / $Precision
    
    collider.rotation_x += (axis_x * collider.inv_rot_int + $Half) / $Precision
    collider.rotation_y += (axis_y * collider.inv_rot_int + $Half) / $Precision
    collider.rotation_z += (axis_z * collider.inv_rot_int + $Half) / $Precision
    
    if collider.sleeping
        collider_wake_up() with macros
    end
end

function collider_apply_spring_cable(spring_x, spring_y, spring_z, spring_neutral, spring_constant, local_att_x, local_att_y, local_att_z)
    define name collider = "collider_$(collider)"

    collider_local_to_world(local_att_x, local_att_y, local_att_z, True) with macros
    
    spring_dx = world_x - spring_x
    spring_dy = world_y - spring_y
    spring_dz = world_z - spring_z
    
    # Current length of the spring
    spring_mag = sqrt(spring_dx*spring_dx + spring_dy*spring_dy + spring_dz*spring_dz)
    
    # Spring displacement from neutral
    spring_disp = spring_mag - spring_neutral
    
    spring_dir_x = spring_dx * $Precision / spring_mag
    spring_dir_y = spring_dy * $Precision / spring_mag
    spring_dir_z = spring_dz * $Precision / spring_mag
    
    if spring_mag > spring_neutral
        force_x = -spring_dir_x * spring_disp / $Precision * spring_constant / $Precision
        force_y = -spring_dir_y * spring_disp / $Precision * spring_constant / $Precision
        force_z = -spring_dir_z * spring_disp / $Precision * spring_constant / $Precision
        
        collider_apply_impulse(world_x, world_y, world_z, force_x, force_y, force_z) with macros
    end
end

function collider_ray_intersection(x, y, z, dx, dy, dz)
    define name collider = "collider_$(collider)"

    collider_world_to_local(x, y, z, True) with macros
    local_origin_x = local_x
    local_origin_y = local_y
    local_origin_z = local_z
    
    collider_world_to_local(dx, dy, dz, False) with macros
    local_dx = local_x
    local_dy = local_y
    local_dz = local_z
    
    if local_dx == 0
        local_dx = 1
    end
    if local_dy == 0
        local_dy = 1
    end
    if local_dz == 0
        local_dz = 1
    end
    
    halfsize = collider.size / 2
    
    # Calculate the times of entry/exit along each axis
    txn = (-halfsize - local_origin_x) * $Precision / local_dx
    txp = (halfsize - local_origin_x) * $Precision / local_dx
    tyn = (-halfsize - local_origin_y) * $Precision / local_dy
    typ = (halfsize - local_origin_y) * $Precision / local_dy
    tzn = (-halfsize - local_origin_z) * $Precision / local_dz
    tzp = (halfsize - local_origin_z) * $Precision / local_dz
    
    # Figure out the minimum and maximum time along the x axis
    if txn > txp
        min_tx = txp
        max_tx = txn
        x_normal = $Precision
    else
        min_tx = txn
        max_tx = txp
        x_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the y axis
    if tyn > typ
        min_ty = typ
        max_ty = tyn
        y_normal = $Precision
    else
        min_ty = tyn
        max_ty = typ
        y_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the z axis
    if tzn > tzp
        min_tz = tzp
        max_tz = tzn
        z_normal = $Precision
    else
        min_tz = tzn
        max_tz = tzp
        z_normal = -$Precision
    end
    
    # Figure out which axis we enter the cube last. Once the ray
    # has entered the cube along all 3 axes, it can collide.
    if min_tx > min_ty and min_tx > min_tz
        min_t = min_tx
        local_cnx = x_normal
        local_cny = 0
        local_cnz = 0
    else if min_ty > min_tz
        min_t = min_ty
        local_cnx = 0
        local_cny = y_normal
        local_cnz = 0
    else
        min_t = min_tz
        local_cnx = 0
        local_cny = 0
        local_cnz = z_normal
    end

    # Figure out which axis we exited the cube first. Once the ray
    # has exited the cube along any axis, it's no longer colliding.
    if max_tx < max_ty and max_tx < max_tz
        max_t = max_tx
    else if max_ty < max_tz
        max_t = max_ty
    else
        max_t = max_tz
    end
    
    # If the ray entered the cube along all three axes before it
    # exited along any axis, and it exited in front of us and not
    # behind us, then the ray intersections the cube, first hitting
    # it at t=min_t.
    if min_t < max_t and max_t > 0
        t = min_t
        
        if t < 0
            t = 0
        end
        
        local_cx = local_origin_x + t * local_dx / $Precision
        local_cy = local_origin_y + t * local_dy / $Precision
        local_cz = local_origin_z + t * local_dz / $Precision
        
        collider_local_to_world(local_cx, local_cy, local_cz, True) with macros
        collision_x = world_x
        collision_y = world_y
        collision_z = world_z
        
        collider_local_to_world(local_cnx, local_cny, local_cnz, False) with macros
        collision_nx = world_x
        collision_ny = world_y
        collision_nz = world_z
        
        return True
    else
        return False
    end
end

function collider_calculate_vertex_world_positions()
    define name collider = "collider_$(collider)"
    
    halfsize = collider.size / 2
    
    # Initialized AABB
    collider.min_x = collider.x
    collider.min_y = collider.y
    collider.min_z = collider.z
    collider.max_x = collider.x
    collider.max_y = collider.y
    collider.max_z = collider.z
    
    for $vertex_pair in [[0, 1, 1, 1], [2, 1, -1, 1], [4, 1, 1, -1], [6, 1, -1, -1]]
        $i = $vertex_pair[0]
        $mx = $vertex_pair[1]
        $my = $vertex_pair[2]
        $mz = $vertex_pair[3]
        
        with
            $(vertex_pos) = $i
            $(vertex_neg) = $i + 1
        do
            define name collider_vertex_pos = "collider_$(collider)_v$(vertex_pos)"
            define name collider_vertex_neg = "collider_$(collider)_v$(vertex_neg)"
            
            collider_local_to_world(halfsize * $mx, halfsize * $my, halfsize * $mz, False) with macros
            collider_vertex_pos.x = collider.x + world_x
            collider_vertex_pos.y = collider.y + world_y
            collider_vertex_pos.z = collider.z + world_z
            
            collider_vertex_neg.x = collider.x - world_x
            collider_vertex_neg.y = collider.y - world_y
            collider_vertex_neg.z = collider.z - world_z
            
            # Expand AABB
            if collider_vertex_pos.x < collider.min_x
                collider.min_x = collider_vertex_pos.x
            end
            if collider_vertex_pos.y < collider.min_y
                collider.min_y = collider_vertex_pos.y
            end
            if collider_vertex_pos.z < collider.min_z
                collider.min_z = collider_vertex_pos.z
            end
            if collider_vertex_pos.x > collider.max_x
                collider.max_x = collider_vertex_pos.x
            end
            if collider_vertex_pos.y > collider.max_y
                collider.max_y = collider_vertex_pos.y
            end
            if collider_vertex_pos.z > collider.max_z
                collider.max_z = collider_vertex_pos.z
            end
            
            if collider_vertex_neg.x < collider.min_x
                collider.min_x = collider_vertex_neg.x
            end
            if collider_vertex_neg.y < collider.min_y
                collider.min_y = collider_vertex_neg.y
            end
            if collider_vertex_neg.z < collider.min_z
                collider.min_z = collider_vertex_neg.z
            end
            if collider_vertex_neg.x > collider.max_x
                collider.max_x = collider_vertex_neg.x
            end
            if collider_vertex_neg.y > collider.max_y
                collider.max_y = collider_vertex_neg.y
            end
            if collider_vertex_neg.z > collider.max_z
                collider.max_z = collider_vertex_neg.z
            end
        end
    end
end

function handle_collision_impulse()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"
    
    /scoreboard players set Global twobody $(collider2)
    
    # Create contact basis/transform
    ct_01 = collision.nx
    ct_11 = collision.ny
    ct_21 = collision.nz
    
    absx = abs(collision.nx)
    absz = abs(collision.nz)
    
    if absx < absz
        # The norm isn't pointing toward x, so
        # cross the norm with 1,0,0
        s = sqrt(collision.ny*collision.ny + collision.nz*collision.nz)
        ct_00 = 0
        ct_10 = -collision.nz * $Precision / s
        ct_20 = collision.ny * $Precision / s

        # Cross the norm with the new vector
        ct_02 = (ct_10*ct_21 - ct_20*ct_11 + $Half) / $Precision
        ct_12 = (ct_20*ct_01 + $Half) / $Precision
        ct_22 = (ct_10*ct_01 + $Half) / $Precision
    else
        # The norm isn't pointing toward z, so
        # cross the norm with 0,0,1
        s = sqrt(collision.ny*collision.ny + collision.nx*collision.nx)
        ct_00 = collision.ny * $Precision / s
        ct_10 = -collision.nx * $Precision / s
        ct_20 = 0

        # Cross the norm with the new vector
        ct_02 = (ct_10*ct_21 + $Half) / $Precision
        ct_12 = (ct_00*ct_21 + $Half) / $Precision
        ct_22 = (ct_00*ct_11 - ct_10*ct_01 + $Half) / $Precision
    end
    
    # Full cross product would be:
    #ct_20 = (ct_10*ct_21 - ct_20*ct_11 + $Half) / $Precision
    #ct_21 = (ct_20*ct_01 - ct_00*ct_21 + $Half) / $Precision
    #ct_22 = (ct_00*ct_11 - ct_10*ct_01 + $Half) / $Precision

    
    # Transform by the ct transpose matrix to get contact coordinates
    c_vel_x = (ct_00 * collision.vel_x + ct_10 * collision.vel_y + ct_20 * collision.vel_z + $Half) / $Precision
    c_vel_y = (ct_01 * collision.vel_x + ct_11 * collision.vel_y + ct_21 * collision.vel_z + $Half) / $Precision
    c_vel_z = (ct_02 * collision.vel_x + ct_12 * collision.vel_y + ct_22 * collision.vel_z + $Half) / $Precision

    # Impulse to torque skew symmetric matrix
    #i_to_t_00 = 0
    #i_to_t_01 = -dz
    #i_to_t_02 = dy
         
    #i_to_t_10 = dz
    #i_to_t_11 = 0
    #i_to_t_12 = -dx
         
    #i_to_t_20 = -dy
    #i_to_t_21 = dx
    #i_to_t_22 = 0
    
    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z
    
    # Impulse to velocity transform
    # Formula: -(i_to_t^2) * InverseRotationalIntertia
    i_to_v_00 = ((dz * dz + dy * dy + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_01 = ((-dy * dx + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_02 = ((-dz * dx + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision

    i_to_v_10 = ((-dx * dy + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_11 = ((dz * dz + dx * dx + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_12 = ((-dz * dy + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision

    i_to_v_20 = ((-dx * dz + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_21 = ((-dy * dz + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    i_to_v_22 = ((dy * dy + dx * dx + $Half) / $Precision * collider1.inv_rot_int + $Half) / $Precision
    
    # Transform i_to_v into contact coordinates before inverting,
    # using change of basis formula
    
    # First, ct^transpose * i_to_v
    with
        $(m1) = "ct"
        $(m2) = "i_to_v"
        $(out) = "m"
    transpose_matrix_multiply()

    # Then, multiply by ct
    with
        $(m1) = "m"
        $(m2) = "ct"
        $(out) = "c_i_to_v"
    matrix_multiply()
    
    inv_mass = collider1.inv_mass
    
    if twobody
        # Impulse to velocity transform
        # Formula: -(i_to_t^2) * InverseRotationalIntertia
        i_to_v_00 = ((dz * dz + dy * dy + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_01 = ((-dy * dx + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_02 = ((-dz * dx + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision

        i_to_v_10 = ((-dx * dy + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_11 = ((dz * dz + dx * dx + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_12 = ((-dz * dy + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision

        i_to_v_20 = ((-dx * dz + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_21 = ((-dy * dz + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        i_to_v_22 = ((dy * dy + dx * dx + $Half) / $Precision * collider2.inv_rot_int + $Half) / $Precision
        
        # Transform i_to_v into contact coordinates before inverting,
        # using change of basis formula
        
        # First, ct^transpose * i_to_v
        with
            $(m1) = "ct"
            $(m2) = "i_to_v"
            $(out) = "m"
        transpose_matrix_multiply()

        # Then, multiply by ct
        with
            $(m1) = "m"
            $(m2) = "ct"
            $(out) = "c_i_to_v_2"
        matrix_multiply()
        
        c_i_to_v_00 += c_i_to_v_2_00
        c_i_to_v_01 += c_i_to_v_2_01
        c_i_to_v_02 += c_i_to_v_2_02
        c_i_to_v_10 += c_i_to_v_2_10
        c_i_to_v_11 += c_i_to_v_2_11
        c_i_to_v_12 += c_i_to_v_2_12
        c_i_to_v_20 += c_i_to_v_2_20
        c_i_to_v_21 += c_i_to_v_2_21
        c_i_to_v_22 += c_i_to_v_2_22
        
        inv_mass += collider2.inv_mass
    end
    
    # In contact space, add the inverse mass to the diagonal
    c_i_to_v_00 += inv_mass
    c_i_to_v_11 += inv_mass
    c_i_to_v_22 += inv_mass

    a = c_i_to_v_00
    b = c_i_to_v_01
    c = c_i_to_v_02
    
    d = c_i_to_v_10
    e = c_i_to_v_11
    f = c_i_to_v_12
    
    g = c_i_to_v_20
    h = c_i_to_v_21
    i = c_i_to_v_22
    
    # Inverse impulse to velocity
    det =  (a * e + $Half) / $Precision * i
    det += (d * h + $Half) / $Precision * c
    det += (g * b + $Half) / $Precision * f
    det -= (a * h + $Half) / $Precision * f
    det -= (g * e + $Half) / $Precision * c
    det -= (d * b + $Half) / $Precision * i
    det += $Half
    det /= $Precision

    v_to_i_00 = (e * i - f * h) / det
    v_to_i_01 = (c * h - b * i) / det
    v_to_i_02 = (b * f - c * e) / det

    v_to_i_10 = (f * g - d * i) / det
    v_to_i_11 = (a * i - c * g) / det
    v_to_i_12 = (c * d - a * f) / det
    
    v_to_i_20 = (d * h - e * g) / det
    v_to_i_21 = (b * g - a * h) / det
    v_to_i_22 = (a * e - b * d) / det
    
    $Restitution = 600
    restitution = $Restitution
    if c_vel_y > $CancelRestitution
        restitution = 0
    end
    
    desired_vx = 0
    # TODO: Add gravity in the positive Y world direction
    desired_vy = (-(c_vel_y) * restitution + $Half) / $Precision
    desired_vz = 0

    desired_dvx = desired_vx - c_vel_x
    desired_dvy = desired_vy - c_vel_y
    desired_dvz = desired_vz - c_vel_z
    
    cix = (v_to_i_00 * desired_dvx + v_to_i_01 * desired_dvy + v_to_i_02 * desired_dvz + $Half) / $Precision
    ciy = (v_to_i_10 * desired_dvx + v_to_i_11 * desired_dvy + v_to_i_12 * desired_dvz + $Half) / $Precision
    ciz = (v_to_i_20 * desired_dvx + v_to_i_21 * desired_dvy + v_to_i_22 * desired_dvz + $Half) / $Precision
    
    planar_impulse = sqrt(cix*cix + ciz*ciz)
    
    $Friction = 800
    max_fric_impulse = (ciy * $Friction + $Half) / $Precision
    
    if planar_impulse > max_fric_impulse
        dir_ix = cix * $Precision / planar_impulse
        dir_iz = ciz * $Precision / planar_impulse
    
        v_per_i_y = c_i_to_v_11 + ((c_i_to_v_10 * dir_ix + c_i_to_v_12 * dir_iz + $Half) / $Precision * $Friction + $Half) / $Precision
        
        ciy = desired_dvy * $Precision / v_per_i_y
        
        cix = ((dir_ix * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
        ciz = ((dir_iz * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
    end
    
    # Transform impulse vector out of contact coordinates
    ix = (ct_00 * cix + ct_01 * ciy + ct_02 * ciz + $Half) / $Precision
    iy = (ct_10 * cix + ct_11 * ciy + ct_12 * ciz + $Half) / $Precision
    iz = (ct_20 * cix + ct_21 * ciy + ct_22 * ciz + $Half) / $Precision

    # collider1.id isn't using define name
    with
        $(collider) = collider1.id
    collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    
    if twobody
        ix *= -1
        iy *= -1
        iz *= -1
        
        with
            $(collider) = collider2.id
        collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    end
end