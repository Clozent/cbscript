import common
import math

$InverseMass = 500
$InverseRotationalIntertia = 500
$Precision = 1000

function register_transform_variables()
    # These lines register the variables for the matrix_multiply functions
    accum = 0
    Thousand = 1000
end

function quaternion_multiply(w1, i1, j1, k1, w2, i2, j2, k2)
    new_w = (w1*w2 - i1*i2 - j1*j2 - k1*k2 + 500) / $Precision
    new_i = (w1*i2 + i1*w2 + j1*k2 - k1*j2 + 500) / $Precision
    new_j = (w1*j2 - i1*k2 + j1*w2 + k1*i2 + 500) / $Precision
    new_k = (w1*k2 + i1*j2 - j1*i2 + k1*w2 + 500) / $Precision
end

# Assumes $namespace:global args contains
# $(m1) $(m2) and $(out), which contain the names of matrices, where a matrix
# has indexed values like m_00, m_01
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:matrix_multiply with storage $namespace:global args
function matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_$row0
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row1
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row2
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= Global Thousand
        end
    end
end

# Transposes m1 before multiplying by m2
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:transpose_matrix_multiply with storage $namespace:global args
function transpose_matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_0$row
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_1$row
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_2$row
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= Global Thousand
        end
    end
end

define @PhysicsDisplay = @Entity
    function initialize_transform()
        @s.t00 = $Precision
        @s.t01 = 0
        @s.t02 = 0
        @s.t10 = 0
        @s.t11 = $Precision
        @s.t12 = 0
        @s.t20 = 0
        @s.t21 = 0
        @s.t22 = $Precision
        @s.tx = 0
        @s.ty = 0
        @s.tz = 0
        
        @s.w = $Precision
        @s.i = 0
        @s.j = 0
        @s.k = 0
        
        @s.clear_velocity()
        @s.clear_rotation()
        
        @s.size = 1000
        @s.inv_mass = $InverseMass
        @s.inv_rot_int = $InverseRotationalIntertia
    end
    
    function set_size(size)
        for iter = 1 to 3
            @s.inv_mass *= @s.size
            @s.inv_mass /= size
        end
        @s.inv_rot_int *= @s.size
        @s.inv_rot_int /= size
        
        @s.size = size
    end
    
    function clear_velocity()
        @s.velocity_x = 0
        @s.velocity_y = 0
        @s.velocity_z = 0
    end
    
    function clear_rotation()
        @s.rotation_x = 0
        @s.rotation_y = 0
        @s.rotation_z = 0
    end
    
    function center_transform()
        @s.tx = (@s.t00 + @s.t01 + @s.t02) / -2
        @s.ty = (@s.t10 + @s.t11 + @s.t12) / -2
        @s.tz = (@s.t20 + @s.t21 + @s.t22) / -2
    end
    
    function rotation_impulse(x, y, z)
        @s.rotation_x += (x * @s.inv_rot_int + 500) / $Precision
        @s.rotation_y += (y * @s.inv_rot_int + 500) / $Precision
        @s.rotation_z += (z * @s.inv_rot_int + 500) / $Precision
    end
    
    function integrate()
        @s.integrate_velocity()
        @s.integrate_rotation()
    end
    
    function integrate_velocity()
        @s.velocity_x *= 980
        @s.velocity_x += 500
        @s.velocity_x /= $Precision
        @s.velocity_y *= 980
        @s.velocity_y += 500
        @s.velocity_y /= $Precision
        @s.velocity_z *= 980
        @s.velocity_z += 500
        @s.velocity_z /= $Precision
        
        if velocity_x < 0 and velocity_x > -25
            velocity_x++
        end
        if velocity_x > 0 and velocity_x < 25
            velocity_x--
        end
        if velocity_y < 0 and velocity_y > -25
            velocity_y++
        end
        if velocity_y > 0 and velocity_y < 25
            velocity_y--
        end
        if velocity_z < 0 and velocity_z > -25
            velocity_z++
        end
        if velocity_z > 0 and velocity_z < 25
            velocity_z--
        end
    
        @s.x += @s.velocity_x
        @s.y += @s.velocity_y
        @s.z += @s.velocity_z
    end
    
    function integrate_rotation()
        @s.rotation_x *= 980
        @s.rotation_x += 500
        @s.rotation_x /= $Precision
        @s.rotation_y *= 980
        @s.rotation_y += 500
        @s.rotation_y /= $Precision
        @s.rotation_z *= 980
        @s.rotation_z += 500
        @s.rotation_z /= $Precision
        
        if rotation_x < 0 and rotation_x > -25
            rotation_x++
        end
        if rotation_x > 0 and rotation_x < 25
            rotation_x--
        end
        if rotation_y < 0 and rotation_y > -25
            rotation_y++
        end
        if rotation_y > 0 and rotation_y < 25
            rotation_y--
        end
        if rotation_z < 0 and rotation_z > -25
            rotation_z++
        end
        if rotation_z > 0 and rotation_z < 25
            rotation_z--
        end

        quaternion_multiply(0, @s.rotation_x, @s.rotation_y, @s.rotation_z, @s.w, @s.i, @s.j, @s.k)
        
        @s.w += new_w / 2
        @s.i += new_i / 2
        @s.j += new_j / 2
        @s.k += new_k / 2

        @s.normalize_quaternion()
    end
    
    function set_transform()
        /data modify storage $namespace:global transformation set value [1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f]
        @s.d00 = @s.t00 * @s.size / $Precision
        @s.d01 = @s.t01 * @s.size / $Precision
        @s.d02 = @s.t02 * @s.size / $Precision
        @s.d10 = @s.t10 * @s.size / $Precision
        @s.d11 = @s.t11 * @s.size / $Precision
        @s.d12 = @s.t12 * @s.size / $Precision
        @s.d20 = @s.t20 * @s.size / $Precision
        @s.d21 = @s.t21 * @s.size / $Precision
        @s.d22 = @s.t22 * @s.size / $Precision
        @s.dx = (@s.d00 + @s.d01 + @s.d02) / -2
        @s.dy = (@s.d10 + @s.d11 + @s.d12) / -2
        @s.dz = (@s.d20 + @s.d21 + @s.d22) / -2
        
        for $pair in [[0,"d00"], [1,"d01"], [2,"d02"], [3,"dx"], [4,"d10"], [5,"d11"], [6,"d12"], [7,"dy"], [8,"d20"], [9,"d21"], [10,"d22"], [11,"dz"]]
            $idx = $pair[0]
            $var = $pair[1]
            $downscale = 1.0 / $Precision
            /execute store result storage $namespace:global transformation[$idx] float $downscale run scoreboard players get @s $var
        end
        
        /data modify entity @s transformation set from storage transform_test:global transformation
        /data modify entity @s start_interpolation set value 0b
    end
    
    function normalize_quaternion()
        mag = sqrt(@s.w*@s.w + @s.i*@s.i + @s.j*@s.j + @s.k*@s.k)
        
        @s.w *= $Precision
        @s.w += 500
        @s.w /= mag
        @s.i *= $Precision
        @s.i += 500
        @s.i /= mag
        @s.j *= $Precision
        @s.j += 500
        @s.j /= mag
        @s.k *= $Precision
        @s.k += 500
        @s.k /= mag
    end

    function multiply_quaternion_right(w, i, j, k)
        quaternion_multiply(@s.w, @s.i, @s.j, @s.k, w, i, j, k)
        
        @s.w = new_w
        @s.i = new_i
        @s.j = new_j
        @s.k = new_k

        @s.normalize_quaternion()
    end
    
    function multiply_quaternion_left(w, i, j, k)
        quaternion_multiply(w, i, j, k, @s.w, @s.i, @s.j, @s.k)
    
        @s.w = new_w
        @s.i = new_i
        @s.j = new_j
        @s.k = new_k

        @s.normalize_quaternion()
    end
    
    function quaternion_to_transform()
        @s.t00 = $Precision - (2 * @s.j * @s.j) / $Precision - (2 * @s.k * @s.k) / $Precision
        @s.t01 = (2 * @s.i * @s.j) / $Precision - (2 * @s.k * @s.w) / $Precision
        @s.t02 = (2 * @s.i * @s.k) / $Precision + (2 * @s.j * @s.w) / $Precision

        @s.t10 = (2 * @s.i * @s.j) / $Precision + (2 * @s.k * @s.w) / $Precision
        @s.t11 = $Precision - (2 * @s.i * @s.i) / $Precision - (2 * @s.k * @s.k) / $Precision
        @s.t12 = (2 * @s.j * @s.k) / $Precision - (2 * @s.i * @s.w) / $Precision

        @s.t20 = (2 * @s.i * @s.k) / $Precision - (2 * @s.j * @s.w) / $Precision
        @s.t21 = (2 * @s.j * @s.k) / $Precision + (2 * @s.i * @s.w) / $Precision
        @s.t22 = $Precision - (2 * @s.i * @s.i) / $Precision - (2 * @s.j * @s.j) / $Precision
    end
    
    function local_to_world(x, y, z, translation)
        world_x = (@s.t00 * x + @s.t01 * y + @s.t02 * z + 500) / $Precision
        world_y = (@s.t10 * x + @s.t11 * y + @s.t12 * z + 500) / $Precision
        world_z = (@s.t20 * x + @s.t21 * y + @s.t22 * z + 500) / $Precision
        
        if translation
            world_x += @s.x
            world_y += @s.y
            world_z += @s.z
        end
    end
    
    function world_to_local(x, y, z, translation)
        if translation
            x -= @s.x
            y -= @s.y
            z -= @s.z
        end
        
        local_x = (@s.t00 * x + @s.t10 * y + @s.t20 * z + 500) / $Precision
        local_y = (@s.t01 * x + @s.t11 * y + @s.t21 * z + 500) / $Precision
        local_z = (@s.t02 * x + @s.t12 * y + @s.t22 * z + 500) / $Precision
    end
    
    function apply_impulse(x, y, z, ix, iy, iz)
        @s.velocity_x += (ix * @s.inv_mass + 500) / $Precision
        @s.velocity_y += (iy * @s.inv_mass + 500) / $Precision
        @s.velocity_z += (iz * @s.inv_mass + 500) / $Precision

        dx = x - @s.x
        dy = y - @s.y
        dz = z - @s.z
        
        axis_x = (dy * iz - dz * iy + 500) / $Precision
        axis_y = (dz * ix - dx * iz + 500) / $Precision
        axis_z = (dx * iy - dy * ix + 500) / $Precision
        
        @s.rotation_impulse(axis_x, axis_y, axis_z)
    end
    
    function apply_spring_cable(spring_x, spring_y, spring_z, spring_neutral, spring_constant, local_att_x, local_att_y, local_att_z)
        @s.local_to_world(local_att_x, local_att_y, local_att_z, True)
        
        spring_dx = world_x - spring_x
        spring_dy = world_y - spring_y
        spring_dz = world_z - spring_z
        
        # Current length of the spring
        spring_mag = sqrt(spring_dx*spring_dx + spring_dy*spring_dy + spring_dz*spring_dz)
        
        # Spring displacement from neutral
        spring_disp = spring_mag - spring_neutral
        
        spring_dir_x = spring_dx * $Precision / spring_mag
        spring_dir_y = spring_dy * $Precision / spring_mag
        spring_dir_z = spring_dz * $Precision / spring_mag
        
        if spring_mag > spring_neutral
            force_x = -spring_dir_x * spring_disp / $Precision * spring_constant / $Precision
            force_y = -spring_dir_y * spring_disp / $Precision * spring_constant / $Precision
            force_z = -spring_dir_z * spring_disp / $Precision * spring_constant / $Precision
            
            @s.apply_impulse(world_x, world_y, world_z, force_x, force_y, force_z)
        end
    end
end

define @PhysicsBlock = @PhysicsDisplay[type=block_display,tag=physics_block]
    function ray_intersection(x, y, z, dx, dy, dz)
        @s.world_to_local(x, y, z, True)
        local_origin_x = local_x
        local_origin_y = local_y
        local_origin_z = local_z
        
        @s.world_to_local(dx, dy, dz, False)
        local_dx = local_x
        local_dy = local_y
        local_dz = local_z
        
        if local_dx == 0
            local_dx = 1
        end
        if local_dy == 0
            local_dy = 1
        end
        if local_dz == 0
            local_dz = 1
        end
        
        halfsize = @s.size / 2
        
        # Calculate the times of entry/exit along each axis
        txn = (-halfsize - local_origin_x) * $Precision / local_dx
        txp = (halfsize - local_origin_x) * $Precision / local_dx
        tyn = (-halfsize - local_origin_y) * $Precision / local_dy
        typ = (halfsize - local_origin_y) * $Precision / local_dy
        tzn = (-halfsize - local_origin_z) * $Precision / local_dz
        tzp = (halfsize - local_origin_z) * $Precision / local_dz
        
        # Figure out the minimum and maximum time along the x axis
        if txn > txp
            min_tx = txp
            max_tx = txn
            x_normal = $Precision
        else
            min_tx = txn
            max_tx = txp
            x_normal = -$Precision
        end
        
        # Figure out the minimum and maximum time along the y axis
        if tyn > typ
            min_ty = typ
            max_ty = tyn
            y_normal = $Precision
        else
            min_ty = tyn
            max_ty = typ
            y_normal = -$Precision
        end
        
        # Figure out the minimum and maximum time along the z axis
        if tzn > tzp
            min_tz = tzp
            max_tz = tzn
            z_normal = $Precision
        else
            min_tz = tzn
            max_tz = tzp
            z_normal = -$Precision
        end
        
        # Figure out which axis we enter the cube last. Once the ray
        # has entered the cube along all 3 axes, it can collide.
        if min_tx > min_ty and min_tx > min_tz
            min_t = min_tx
            local_cnx = x_normal
            local_cny = 0
            local_cnz = 0
        else if min_ty > min_tz
            min_t = min_ty
            local_cnx = 0
            local_cny = y_normal
            local_cnz = 0
        else
            min_t = min_tz
            local_cnx = 0
            local_cny = 0
            local_cnz = z_normal
        end

        # Figure out which axis we exited the cube first. Once the ray
        # has exited the cube along any axis, it's no longer colliding.
        if max_tx < max_ty and max_tx < max_tz
            max_t = max_tx
        else if max_ty < max_tz
            max_t = max_ty
        else
            max_t = max_tz
        end
        
        # If the ray entered the cube along all three axes before it
        # exited along any axis, and it exited in front of us and not
        # behind us, then the ray intersections the cube, first hitting
        # it at t=min_t.
        if min_t < max_t and max_t > 0
            t = min_t
            
            if t < 0
                t = 0
            end
            
            local_cx = local_origin_x + t * local_dx / $Precision
            local_cy = local_origin_y + t * local_dy / $Precision
            local_cz = local_origin_z + t * local_dz / $Precision
            
            @s.collision = True
            
            @s.local_to_world(local_cx, local_cy, local_cz, True)            
            @s.collision_x = world_x
            @s.collision_y = world_y
            @s.collision_z = world_z
            
            @s.local_to_world(local_cnx, local_cny, local_cnz, False)
            @s.collision_nx = world_x
            @s.collision_ny = world_y
            @s.collision_nz = world_z
        else
            @s.collision = False
        end
    end
end
