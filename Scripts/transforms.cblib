import common
import math

$InverseMass = 500
$InverseRotationalIntertia = 500
$Precision = 1000
$CancelRestitution = -25

# These lines register the variables for the matrix_multiply functions
# It doesn't actually need to be called.
function register_transform_variables()
    accum = 0
end

function quaternion_multiply(w1, i1, j1, k1, w2, i2, j2, k2)
    new_w = (w1*w2 - i1*i2 - j1*j2 - k1*k2 + 500) / $Precision
    new_i = (w1*i2 + i1*w2 + j1*k2 - k1*j2 + 500) / $Precision
    new_j = (w1*j2 - i1*k2 + j1*w2 + k1*i2 + 500) / $Precision
    new_k = (w1*k2 + i1*j2 - j1*i2 + k1*w2 + 500) / $Precision
end

# Assumes $namespace:global args contains
# $(m1) $(m2) and $(out), which contain the names of matrices, where a matrix
# has indexed values like m_00, m_01
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:matrix_multiply with storage $namespace:global args
function matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_$row0
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row1
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_$row2
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= c1000 Constant
        end
    end
end

# Transposes m1 before multiplying by m2
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:transpose_matrix_multiply with storage $namespace:global args
function transpose_matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score Global $(out)_$row$col run scoreboard players get Global $(m1)_0$row
            /$scoreboard players operation Global $(out)_$row$col *= Global $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get Global $(m1)_1$row
            /$scoreboard players operation Global accum *= Global $(m2)_1$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get Global $(m1)_2$row
            /$scoreboard players operation Global accum *= Global $(m2)_2$col
            /$scoreboard players operation Global $(out)_$row$col += Global accum
            /$scoreboard players operation Global $(out)_$row$col /= c1000 Constant
        end
    end
end

define @PhysicsDisplay = @Entity
    function initialize_transform()
        @s.t00 = $Precision
        @s.t01 = 0
        @s.t02 = 0
        @s.t10 = 0
        @s.t11 = $Precision
        @s.t12 = 0
        @s.t20 = 0
        @s.t21 = 0
        @s.t22 = $Precision
        @s.tx = 0
        @s.ty = 0
        @s.tz = 0
        
        @s.w = $Precision
        @s.i = 0
        @s.j = 0
        @s.k = 0
        
        @s.clear_velocity()
        @s.clear_rotation()
        
        @s.size = 1000
        @s.inv_mass = $InverseMass
        @s.inv_rot_int = $InverseRotationalIntertia
    end
    
    function set_size(size)
        for iter = 1 to 3
            @s.inv_mass *= @s.size
            @s.inv_mass /= size
        end
        @s.inv_rot_int *= @s.size
        @s.inv_rot_int /= size
        
        @s.size = size
    end
    
    function clear_velocity()
        @s.velocity_x = 0
        @s.velocity_y = 0
        @s.velocity_z = 0
    end
    
    function clear_rotation()
        @s.rotation_x = 0
        @s.rotation_y = 0
        @s.rotation_z = 0
    end
    
    function center_transform()
        @s.tx = (@s.t00 + @s.t01 + @s.t02) / -2
        @s.ty = (@s.t10 + @s.t11 + @s.t12) / -2
        @s.tz = (@s.t20 + @s.t21 + @s.t22) / -2
    end
    
    function rotation_impulse(x, y, z)
        @s.rotation_x += (x * @s.inv_rot_int + 500) / $Precision
        @s.rotation_y += (y * @s.inv_rot_int + 500) / $Precision
        @s.rotation_z += (z * @s.inv_rot_int + 500) / $Precision
    end
    
    function integrate()
        @s.integrate_velocity()
        @s.integrate_rotation()
    end
    
    function integrate_velocity()
        @s.velocity_x *= 980
        @s.velocity_x += 500
        @s.velocity_x /= $Precision
        @s.velocity_y *= 980
        @s.velocity_y += 500
        @s.velocity_y /= $Precision
        @s.velocity_z *= 980
        @s.velocity_z += 500
        @s.velocity_z /= $Precision
        
        if velocity_x < 0 and velocity_x > -25
            velocity_x++
        end
        if velocity_x > 0 and velocity_x < 25
            velocity_x--
        end
        if velocity_y < 0 and velocity_y > -25
            velocity_y++
        end
        if velocity_y > 0 and velocity_y < 25
            velocity_y--
        end
        if velocity_z < 0 and velocity_z > -25
            velocity_z++
        end
        if velocity_z > 0 and velocity_z < 25
            velocity_z--
        end
    
        @s.x += @s.velocity_x
        @s.y += @s.velocity_y
        @s.z += @s.velocity_z
    end
    
    function integrate_rotation()
        @s.rotation_x *= 980
        @s.rotation_x += 500
        @s.rotation_x /= $Precision
        @s.rotation_y *= 980
        @s.rotation_y += 500
        @s.rotation_y /= $Precision
        @s.rotation_z *= 980
        @s.rotation_z += 500
        @s.rotation_z /= $Precision
        
        if rotation_x < 0 and rotation_x > -25
            rotation_x++
        end
        if rotation_x > 0 and rotation_x < 25
            rotation_x--
        end
        if rotation_y < 0 and rotation_y > -25
            rotation_y++
        end
        if rotation_y > 0 and rotation_y < 25
            rotation_y--
        end
        if rotation_z < 0 and rotation_z > -25
            rotation_z++
        end
        if rotation_z > 0 and rotation_z < 25
            rotation_z--
        end

        quaternion_multiply(0, @s.rotation_x, @s.rotation_y, @s.rotation_z, @s.w, @s.i, @s.j, @s.k)
        
        @s.w += new_w / 2
        @s.i += new_i / 2
        @s.j += new_j / 2
        @s.k += new_k / 2

        @s.normalize_quaternion()
    end
    
    function set_transform()
        /data modify storage $namespace:global transformation set value [1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f]
        @s.d00 = @s.t00 * @s.size / $Precision
        @s.d01 = @s.t01 * @s.size / $Precision
        @s.d02 = @s.t02 * @s.size / $Precision
        @s.d10 = @s.t10 * @s.size / $Precision
        @s.d11 = @s.t11 * @s.size / $Precision
        @s.d12 = @s.t12 * @s.size / $Precision
        @s.d20 = @s.t20 * @s.size / $Precision
        @s.d21 = @s.t21 * @s.size / $Precision
        @s.d22 = @s.t22 * @s.size / $Precision
        @s.dx = (@s.d00 + @s.d01 + @s.d02) / -2
        @s.dy = (@s.d10 + @s.d11 + @s.d12) / -2
        @s.dz = (@s.d20 + @s.d21 + @s.d22) / -2
        
        for $pair in [[0,"d00"], [1,"d01"], [2,"d02"], [3,"dx"], [4,"d10"], [5,"d11"], [6,"d12"], [7,"dy"], [8,"d20"], [9,"d21"], [10,"d22"], [11,"dz"]]
            $idx = $pair[0]
            $var = $pair[1]
            $downscale = 1.0 / $Precision
            /execute store result storage $namespace:global transformation[$idx] float $downscale run scoreboard players get @s $var
        end
        
        /data modify entity @s transformation set from storage transform_test:global transformation
        /data modify entity @s start_interpolation set value 0b
    end
    
    function normalize_quaternion()
        mag = sqrt(@s.w*@s.w + @s.i*@s.i + @s.j*@s.j + @s.k*@s.k)
        
        @s.w *= $Precision
        @s.w += 500
        @s.w /= mag
        @s.i *= $Precision
        @s.i += 500
        @s.i /= mag
        @s.j *= $Precision
        @s.j += 500
        @s.j /= mag
        @s.k *= $Precision
        @s.k += 500
        @s.k /= mag
    end

    function multiply_quaternion_right(w, i, j, k)
        quaternion_multiply(@s.w, @s.i, @s.j, @s.k, w, i, j, k)
        
        @s.w = new_w
        @s.i = new_i
        @s.j = new_j
        @s.k = new_k

        @s.normalize_quaternion()
    end
    
    function multiply_quaternion_left(w, i, j, k)
        quaternion_multiply(w, i, j, k, @s.w, @s.i, @s.j, @s.k)
    
        @s.w = new_w
        @s.i = new_i
        @s.j = new_j
        @s.k = new_k

        @s.normalize_quaternion()
    end
    
    function quaternion_to_transform()
        @s.t00 = $Precision - (2 * @s.j * @s.j) / $Precision - (2 * @s.k * @s.k) / $Precision
        @s.t01 = (2 * @s.i * @s.j) / $Precision - (2 * @s.k * @s.w) / $Precision
        @s.t02 = (2 * @s.i * @s.k) / $Precision + (2 * @s.j * @s.w) / $Precision

        @s.t10 = (2 * @s.i * @s.j) / $Precision + (2 * @s.k * @s.w) / $Precision
        @s.t11 = $Precision - (2 * @s.i * @s.i) / $Precision - (2 * @s.k * @s.k) / $Precision
        @s.t12 = (2 * @s.j * @s.k) / $Precision - (2 * @s.i * @s.w) / $Precision

        @s.t20 = (2 * @s.i * @s.k) / $Precision - (2 * @s.j * @s.w) / $Precision
        @s.t21 = (2 * @s.j * @s.k) / $Precision + (2 * @s.i * @s.w) / $Precision
        @s.t22 = $Precision - (2 * @s.i * @s.i) / $Precision - (2 * @s.j * @s.j) / $Precision
    end
    
    function local_to_world(x, y, z, translation)
        world_x = (@s.t00 * x + @s.t01 * y + @s.t02 * z + 500) / $Precision
        world_y = (@s.t10 * x + @s.t11 * y + @s.t12 * z + 500) / $Precision
        world_z = (@s.t20 * x + @s.t21 * y + @s.t22 * z + 500) / $Precision
        
        if translation
            world_x += @s.x
            world_y += @s.y
            world_z += @s.z
        end
    end
    
    function world_to_local(x, y, z, translation)
        if translation
            x -= @s.x
            y -= @s.y
            z -= @s.z
        end
        
        local_x = (@s.t00 * x + @s.t10 * y + @s.t20 * z + 500) / $Precision
        local_y = (@s.t01 * x + @s.t11 * y + @s.t21 * z + 500) / $Precision
        local_z = (@s.t02 * x + @s.t12 * y + @s.t22 * z + 500) / $Precision
    end
    
    function apply_impulse(x, y, z, ix, iy, iz)
        @s.velocity_x += (ix * @s.inv_mass + 500) / $Precision
        @s.velocity_y += (iy * @s.inv_mass + 500) / $Precision
        @s.velocity_z += (iz * @s.inv_mass + 500) / $Precision

        dx = x - @s.x
        dy = y - @s.y
        dz = z - @s.z
        
        axis_x = (dy * iz - dz * iy + 500) / $Precision
        axis_y = (dz * ix - dx * iz + 500) / $Precision
        axis_z = (dx * iy - dy * ix + 500) / $Precision
        
        @s.rotation_impulse(axis_x, axis_y, axis_z)
    end
    
    function apply_spring_cable(spring_x, spring_y, spring_z, spring_neutral, spring_constant, local_att_x, local_att_y, local_att_z)
        @s.local_to_world(local_att_x, local_att_y, local_att_z, True)
        
        spring_dx = world_x - spring_x
        spring_dy = world_y - spring_y
        spring_dz = world_z - spring_z
        
        # Current length of the spring
        spring_mag = sqrt(spring_dx*spring_dx + spring_dy*spring_dy + spring_dz*spring_dz)
        
        # Spring displacement from neutral
        spring_disp = spring_mag - spring_neutral
        
        spring_dir_x = spring_dx * $Precision / spring_mag
        spring_dir_y = spring_dy * $Precision / spring_mag
        spring_dir_z = spring_dz * $Precision / spring_mag
        
        if spring_mag > spring_neutral
            force_x = -spring_dir_x * spring_disp / $Precision * spring_constant / $Precision
            force_y = -spring_dir_y * spring_disp / $Precision * spring_constant / $Precision
            force_z = -spring_dir_z * spring_disp / $Precision * spring_constant / $Precision
            
            @s.apply_impulse(world_x, world_y, world_z, force_x, force_y, force_z)
        end
    end
end

define @PhysicsBlock = @PhysicsDisplay[type=block_display,tag=physics_block]
    function ray_intersection(x, y, z, dx, dy, dz)
        @s.world_to_local(x, y, z, True)
        local_origin_x = local_x
        local_origin_y = local_y
        local_origin_z = local_z
        
        @s.world_to_local(dx, dy, dz, False)
        local_dx = local_x
        local_dy = local_y
        local_dz = local_z
        
        if local_dx == 0
            local_dx = 1
        end
        if local_dy == 0
            local_dy = 1
        end
        if local_dz == 0
            local_dz = 1
        end
        
        halfsize = @s.size / 2
        
        # Calculate the times of entry/exit along each axis
        txn = (-halfsize - local_origin_x) * $Precision / local_dx
        txp = (halfsize - local_origin_x) * $Precision / local_dx
        tyn = (-halfsize - local_origin_y) * $Precision / local_dy
        typ = (halfsize - local_origin_y) * $Precision / local_dy
        tzn = (-halfsize - local_origin_z) * $Precision / local_dz
        tzp = (halfsize - local_origin_z) * $Precision / local_dz
        
        # Figure out the minimum and maximum time along the x axis
        if txn > txp
            min_tx = txp
            max_tx = txn
            x_normal = $Precision
        else
            min_tx = txn
            max_tx = txp
            x_normal = -$Precision
        end
        
        # Figure out the minimum and maximum time along the y axis
        if tyn > typ
            min_ty = typ
            max_ty = tyn
            y_normal = $Precision
        else
            min_ty = tyn
            max_ty = typ
            y_normal = -$Precision
        end
        
        # Figure out the minimum and maximum time along the z axis
        if tzn > tzp
            min_tz = tzp
            max_tz = tzn
            z_normal = $Precision
        else
            min_tz = tzn
            max_tz = tzp
            z_normal = -$Precision
        end
        
        # Figure out which axis we enter the cube last. Once the ray
        # has entered the cube along all 3 axes, it can collide.
        if min_tx > min_ty and min_tx > min_tz
            min_t = min_tx
            local_cnx = x_normal
            local_cny = 0
            local_cnz = 0
        else if min_ty > min_tz
            min_t = min_ty
            local_cnx = 0
            local_cny = y_normal
            local_cnz = 0
        else
            min_t = min_tz
            local_cnx = 0
            local_cny = 0
            local_cnz = z_normal
        end

        # Figure out which axis we exited the cube first. Once the ray
        # has exited the cube along any axis, it's no longer colliding.
        if max_tx < max_ty and max_tx < max_tz
            max_t = max_tx
        else if max_ty < max_tz
            max_t = max_ty
        else
            max_t = max_tz
        end
        
        # If the ray entered the cube along all three axes before it
        # exited along any axis, and it exited in front of us and not
        # behind us, then the ray intersections the cube, first hitting
        # it at t=min_t.
        if min_t < max_t and max_t > 0
            t = min_t
            
            if t < 0
                t = 0
            end
            
            local_cx = local_origin_x + t * local_dx / $Precision
            local_cy = local_origin_y + t * local_dy / $Precision
            local_cz = local_origin_z + t * local_dz / $Precision
            
            @s.collision = True
            
            @s.local_to_world(local_cx, local_cy, local_cz, True)            
            @s.collision_x = world_x
            @s.collision_y = world_y
            @s.collision_z = world_z
            
            @s.local_to_world(local_cnx, local_cny, local_cnz, False)
            @s.collision_nx = world_x
            @s.collision_ny = world_y
            @s.collision_nz = world_z
        else
            @s.collision = False
        end
    end
end

function handle_collision_1body()
    define name collider1 = "collider$(collider1)"
    define name collision = "collision$(collision)"

    # Create contact basis/transform
    ct_01 = collision.norm_x
    ct_11 = collision.norm_y
    ct_21 = collision.norm_z
    
    absx = abs(collision.norm_x)
    absz = abs(collision.norm_z)
    
    if absx < absz
        # The norm isn't pointing toward x, so
        # cross the norm with 1,0,0
        s = sqrt(collision.norm_y*collision.norm_y + collision.norm_z*collision.norm_z)
        ct_00 = 0
        ct_10 = -collision.norm_z * $Precision / s
        ct_20 = collision.norm_y * $Precision / s

        # Cross the norm with the new vector
        ct_02 = (ct_10*ct_21 - ct_20*ct_11 + 500) / $Precision
        ct_12 = (ct_20*ct_01 + 500) / $Precision
        ct_22 = (ct_10*ct_01 + 500) / $Precision
    else
        # The norm isn't pointing toward z, so
        # cross the norm with 0,0,1
        s = sqrt(collision.norm_y*collision.norm_y + collision.norm_x*collision.norm_x)
        ct_00 = collision.norm_y * $Precision / s
        ct_10 = -collision.norm_x * $Precision / s
        ct_20 = 0

        # Cross the norm with the new vector
        ct_02 = (ct_10*ct_21 + 500) / $Precision
        ct_12 = (ct_00*ct_21 + 500) / $Precision
        ct_22 = (ct_00*ct_11 - ct_10*ct_01 + 500) / $Precision
    end
    
    # Full cross product would be:
    #ct_20 = (ct_10*ct_21 - ct_20*ct_11 + 500) / $Precision
    #ct_21 = (ct_20*ct_01 - ct_00*ct_21 + 500) / $Precision
    #ct_22 = (ct_00*ct_11 - ct_10*ct_01 + 500) / $Precision

    
    dx = collision.pen_x - collider1.x
    dy = collision.pen_y - collider1.y
    dz = collision.pen_z - collider1.z
    
    rot_lin_vel_x = (collider1.rotation_y * dz - collider1.rotation_z * dy + 500) / $Precision
    rot_lin_vel_y = (collider1.rotation_z * dx - collider1.rotation_x * dz + 500) / $Precision
    rot_lin_vel_z = (collider1.rotation_x * dy - collider1.rotation_y * dx + 500) / $Precision
    
    w_vel_x = collider1.velocity_x + rot_lin_vel_x
    w_vel_y = collider1.velocity_y + rot_lin_vel_y
    w_vel_z = collider1.velocity_z + rot_lin_vel_z
    
    # Transform by the ct transpose matrix to get contact coordinates
    c_vel_x = (ct_00 * w_vel_x + ct_10 * w_vel_y + ct_20 * w_vel_z + 500) / $Precision
    c_vel_y = (ct_01 * w_vel_x + ct_11 * w_vel_y + ct_21 * w_vel_z + 500) / $Precision
    c_vel_z = (ct_02 * w_vel_x + ct_12 * w_vel_y + ct_22 * w_vel_z + 500) / $Precision

    # Impulse to torque skew symmetric matrix
    #i_to_t_00 = 0
    #i_to_t_01 = -dz
    #i_to_t_02 = dy
         
    #i_to_t_10 = dz
    #i_to_t_11 = 0
    #i_to_t_12 = -dx
         
    #i_to_t_20 = -dy
    #i_to_t_21 = dx
    #i_to_t_22 = 0
    
    # Impulse to velocity transform
    # Formula: -(i_to_t^2) * InverseRotationalIntertia
    i_to_v_00 = ((dz * dz + dy * dy + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_01 = ((-dy * dx + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_02 = ((-dz * dx + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision

    i_to_v_10 = ((-dx * dy + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_11 = ((dz * dz + dx * dx + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_12 = ((-dz * dy + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision

    i_to_v_20 = ((-dx * dz + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_21 = ((-dy * dz + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    i_to_v_22 = ((dy * dy + dx * dx + 500) / $Precision * collider1.inv_rot_int + 500) / $Precision
    
    i_to_v_00 += collider1.inv_mass
    i_to_v_11 += collider1.inv_mass
    i_to_v_22 += collider1.inv_mass
    
    # Transform i_to_v into contact coordinates before inverting,
    # using change of basis formula
    
    # First, ct^transpose * i_to_v
    /data merge storage $namespace:global {args:{m1:"ct",m2:"i_to_v",out:"m"}}
    /function $namespace:transpose_matrix_multiply with storage $namespace:global args

    # Then, multiply by ct
    /data merge storage $namespace:global {args:{m1:"m",m2:"ct",out:"c_i_to_v"}}
    /function $namespace:matrix_multiply with storage $namespace:global args
    
    a = c_i_to_v_00
    b = c_i_to_v_01
    c = c_i_to_v_02
    
    d = c_i_to_v_10
    e = c_i_to_v_11
    f = c_i_to_v_12
    
    g = c_i_to_v_20
    h = c_i_to_v_21
    i = c_i_to_v_22
    
    # Inverse impulse to velocity
    det = ((a * e + 500) / $Precision * i + (d * h + 500) / $Precision * c + (g * b + 500) / $Precision * f - (a * h + 500) / $Precision * f - (g * e + 500) / $Precision * c - (d * b + 500) / $Precision * i + 500) / $Precision

    v_to_i_00 = (e * i - f * h) / det
    v_to_i_01 = (c * h - b * i) / det
    v_to_i_02 = (b * f - c * e) / det

    v_to_i_10 = (f * g - d * i) / det
    v_to_i_11 = (a * i - c * g) / det
    v_to_i_12 = (c * d - a * f) / det
    
    v_to_i_20 = (d * h - e * g) / det
    v_to_i_21 = (b * g - a * h) / det
    v_to_i_22 = (a * e - b * d) / det
    
    $Restitution = 200
    restitution = $Restitution
    if c_vel_y > $CancelRestitution
        restitution = 0
    end
    
    desired_vx = 0
    # TODO: Add gravity in the positive Y world direction
    desired_vy = (-(c_vel_y) * restitution + 500) / $Precision
    desired_vz = 0

    desired_dvx = desired_vx - c_vel_x
    desired_dvy = desired_vy - c_vel_y
    desired_dvz = desired_vz - c_vel_z
    
    cix = (v_to_i_00 * desired_dvx + v_to_i_01 * desired_dvy + v_to_i_02 * desired_dvz + 500) / $Precision
    ciy = (v_to_i_10 * desired_dvx + v_to_i_11 * desired_dvy + v_to_i_12 * desired_dvz + 500) / $Precision
    ciz = (v_to_i_20 * desired_dvx + v_to_i_21 * desired_dvy + v_to_i_22 * desired_dvz + 500) / $Precision
    
    planar_impulse = sqrt(cix*cix + ciz*ciz)
    
    $Friction = 800
    max_fric_impulse = (ciy * $Friction + 500) / $Precision
    
    if planar_impulse > max_fric_impulse
        dir_ix = cix * $Precision / planar_impulse
        dir_iz = ciz * $Precision / planar_impulse
    
        v_per_i_y = c_i_to_v_11 + ((c_i_to_v_10 * dir_ix + c_i_to_v_12 * dir_iz + 500) / $Precision * $Friction + 500) / $Precision
        
        ciy = desired_dvy * $Precision / v_per_i_y
        
        cix = ((dir_ix * $Friction + 500) / $Precision * ciy + 500) / $Precision
        ciz = ((dir_iz * $Friction + 500) / $Precision * ciy + 500) / $Precision
    end
    
    # Transform impulse vector out of contact coordinates
    collider1.ix = (ct_00 * cix + ct_01 * ciy + ct_02 * ciz + 500) / $Precision
    collider1.iy = (ct_10 * cix + ct_11 * ciy + ct_12 * ciz + 500) / $Precision
    collider1.iz = (ct_20 * cix + ct_21 * ciy + ct_22 * ciz + 500) / $Precision
end