import common
import math

$InverseMass = 500
$InverseRotationalIntertia = 500
$Precision = 1000
$Half = 500
$CancelRestitution = -100

define @PhysicsBlock = @Entity[type=block_display,tag=physics_block]

end

function initialize_transforms()
    initialize_vertex_adjacency()
end


# These lines register the variables for the matrix_multiply functions
# It doesn't actually need to be called.
function register_transform_variables()
    accum = 0
    m_00 = 0
    m_01 = 0
    m_02 = 0
    m_10 = 0
    m_11 = 0
    m_12 = 0
    m_20 = 0
    m_21 = 0
    m_22 = 0
end

function quaternion_multiply(w1, i1, j1, k1, w2, i2, j2, k2)
    new_w = (w1*w2 - i1*i2 - j1*j2 - k1*k2) / $Precision
    new_i = (w1*i2 + i1*w2 + j1*k2 - k1*j2) / $Precision
    new_j = (w1*j2 - i1*k2 + j1*w2 + k1*i2) / $Precision
    new_k = (w1*k2 + i1*j2 - j1*i2 + k1*w2) / $Precision
end

# Assumes $namespace:global args contains
# $(m1) $(m2) and $(out), which contain the names of matrices, where a matrix
# has indexed values like m_00, m_01
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:matrix_multiply with storage $namespace:global args
function matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score $(out)_$row$col run scoreboard players get $(m1)_$row0
            /$scoreboard players operation $(out)_$row$col *= $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get $(m1)_$row1
            /$scoreboard players operation Global accum *= $(m2)_1$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get $(m1)_$row2
            /$scoreboard players operation Global accum *= $(m2)_2$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$scoreboard players operation $(out)_$row$col /= c1000 Constant
        end
    end
end

# Transposes m1 before multiplying by m2
#/data merge storage $namespace:global {args:{m1:"m",m2:"n",out:"o"}}
#/function $namespace:transpose_matrix_multiply with storage $namespace:global args
function transpose_matrix_multiply()
    for $row in [0, 1, 2]
        for $col in [0, 1, 2]
            /$execute store result score $(out)_$row$col run scoreboard players get $(m1)_0$row
            /$scoreboard players operation $(out)_$row$col *= $(m2)_0$col
            /$execute store result score Global accum run scoreboard players get $(m1)_1$row
            /$scoreboard players operation Global accum *= $(m2)_1$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$execute store result score Global accum run scoreboard players get $(m1)_2$row
            /$scoreboard players operation Global accum *= $(m2)_2$col
            /$scoreboard players operation $(out)_$row$col += Global accum
            /$scoreboard players operation $(out)_$row$col /= c1000 Constant
        end
    end
end

function create_collider(x, y, z, size, inv_mass, inv_rot_int)
    define name collider = "collider_$(collider)"
    
    /scoreboard players set collider_$(collider) id $(collider)
    
    collider.x = x
    collider.y = y
    collider.z = z
    collider.size = size
    collider.halfsize = size / 2
    collider.inv_mass = inv_mass
    collider.inv_rot_int = inv_rot_int
    
    collider.w = $Precision
    collider.i = 0
    collider.j = 0
    collider.k = 0
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider_wake_up() with macros
    
    collider_quaternion_to_transform() with macros

    /$summon minecraft:block_display ~ ~ ~ {block_state:{Name:"minecraft:$(block_name)",Count:0b}, interpolation_duration: 1, teleport_duration: 1, Tags:["physics_block"]}
    @PhysicsBlock.age++
    as @PhysicsBlock[age == 1]
        /scoreboard players set @s collider_id $(collider)
        @s.x = x
        @s.y = y
        @s.z = z
    end
end

function collider_clear_velocity()
    define name collider = "collider_$(collider)"

    collider.velocity_x = 0
    collider.velocity_y = 0
    collider.velocity_z = 0
end

function collider_clear_rotation()
    define name collider = "collider_$(collider)"

    collider.rotation_x = 0
    collider.rotation_y = 0
    collider.rotation_z = 0
end

function collider_wake_up()
    define name collider = "collider_$(collider)"

    collider.recent_motion = 10000
    collider.recent_rotation = 10000
    collider.sleeping = False
end

function collider_sleep()
    define name collider = "collider_$(collider)"
    
    collider_clear_velocity() with macros
    collider_clear_rotation() with macros
    collider.sleeping = True
end

function collider_check_sleep()
    define name collider = "collider_$(collider)"
    
    if collider.recent_motion < 2500 and collider.recent_rotation < 2500
        collider_sleep() with macros
    end
end

function collider_integrate()
    define name collider = "collider_$(collider)"
    
    collider_integrate_velocity() with macros
    collider_integrate_rotation() with macros
end

function collider_integrate_velocity()
    define name collider = "collider_$(collider)"
    
    collider.velocity_x = (collider.velocity_x * 995 + $Half) / $Precision
    collider.velocity_y = (collider.velocity_y * 995 + $Half) / $Precision
    collider.velocity_z = (collider.velocity_z * 995 + $Half) / $Precision
    
    collider.x += collider.velocity_x
    collider.y += collider.velocity_y
    collider.z += collider.velocity_z
    
    motion = (collider.velocity_x * collider.velocity_x + collider.velocity_y * collider.velocity_y + collider.velocity_z * collider.velocity_z) / 10
    collider.recent_motion *= 9
    collider.recent_motion /= 10
    collider.recent_motion += motion
end

function collider_integrate_rotation()
    define name collider = "collider_$(collider)"
    
    collider.rotation_x = (collider.rotation_x * 995 + $Half) / $Precision
    collider.rotation_y = (collider.rotation_y * 995 + $Half) / $Precision
    collider.rotation_z = (collider.rotation_z * 995 + $Half) / $Precision
    
    quaternion_multiply(0, collider.rotation_x, collider.rotation_y, collider.rotation_z, collider.w, collider.i, collider.j, collider.k)
    
    collider.w += new_w / 2
    collider.i += new_i / 2
    collider.j += new_j / 2
    collider.k += new_k / 2

    collider_normalize_quaternion() with macros

    rotation = (collider.rotation_x * collider.rotation_x + collider.rotation_y * collider.rotation_y + collider.rotation_z * collider.rotation_z) / 10
    collider.recent_rotation *= 9
    collider.recent_rotation /= 10
    collider.recent_rotation += motion
end

function collider_set_transform()
    define name collider = "collider_$(collider)"

    /data modify storage $namespace:global transformation set value [1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f,0f,0f,0f,0f,1f]
    d00 = collider.t00 * collider.size / $Precision
    d01 = collider.t01 * collider.size / $Precision
    d02 = collider.t02 * collider.size / $Precision
    d10 = collider.t10 * collider.size / $Precision
    d11 = collider.t11 * collider.size / $Precision
    d12 = collider.t12 * collider.size / $Precision
    d20 = collider.t20 * collider.size / $Precision
    d21 = collider.t21 * collider.size / $Precision
    d22 = collider.t22 * collider.size / $Precision
    dx = (d00 + d01 + d02) / -2
    dy = (d10 + d11 + d12) / -2
    dz = (d20 + d21 + d22) / -2
    
    for $pair in [[0,"d00"], [1,"d01"], [2,"d02"], [3,"dx"], [4,"d10"], [5,"d11"], [6,"d12"], [7,"dy"], [8,"d20"], [9,"d21"], [10,"d22"], [11,"dz"]]
        $idx = $pair[0]
        $var = $pair[1]
        $downscale = 1.0 / $Precision
        /execute store result storage $namespace:global transformation[$idx] float $downscale run scoreboard players get Global $var
    end
    
    as @PhysicsBlock
        if @s.collider_id == collider.id
            @s.x = collider.x
            @s.y = collider.y
            @s.z = collider.z
            /data modify entity @s transformation set from storage transform_test:global transformation
            /data modify entity @s start_interpolation set value 0b
        end
    end
end

function collider_normalize_quaternion()
    define name collider = "collider_$(collider)"

    mag = sqrt(collider.w*collider.w + collider.i*collider.i + collider.j*collider.j + collider.k*collider.k)
    
    collider.w *= $Precision
    collider.w += $Half
    collider.w /= mag
    collider.i *= $Precision
    collider.i += $Half
    collider.i /= mag
    collider.j *= $Precision
    collider.j += $Half
    collider.j /= mag
    collider.k *= $Precision
    collider.k += $Half
    collider.k /= mag
end

function collider_multiply_quaternion_right(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(collider.w, collider.i, collider.j, collider.k, w, i, j, k)
    
    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_multiply_quaternion_left(w, i, j, k)
    define name collider = "collider_$(collider)"

    quaternion_multiply(w, i, j, k, collider.w, collider.i, collider.j, collider.k)

    collider.w = new_w
    collider.i = new_i
    collider.j = new_j
    collider.k = new_k

    collider_normalize_quaternion() with macros
end

function collider_quaternion_to_transform()
    define name collider = "collider_$(collider)"

    collider.t00 = $Precision - (2 * collider.j * collider.j) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t01 = (2 * collider.i * collider.j) / $Precision - (2 * collider.k * collider.w) / $Precision
    collider.t02 = (2 * collider.i * collider.k) / $Precision + (2 * collider.j * collider.w) / $Precision

    collider.t10 = (2 * collider.i * collider.j) / $Precision + (2 * collider.k * collider.w) / $Precision
    collider.t11 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.k * collider.k) / $Precision
    collider.t12 = (2 * collider.j * collider.k) / $Precision - (2 * collider.i * collider.w) / $Precision

    collider.t20 = (2 * collider.i * collider.k) / $Precision - (2 * collider.j * collider.w) / $Precision
    collider.t21 = (2 * collider.j * collider.k) / $Precision + (2 * collider.i * collider.w) / $Precision
    collider.t22 = $Precision - (2 * collider.i * collider.i) / $Precision - (2 * collider.j * collider.j) / $Precision
end

function collider_local_to_world(x, y, z, translation)
    define name collider = "collider_$(collider)"

    world_x = (collider.t00 * x + collider.t01 * y + collider.t02 * z) / $Precision
    world_y = (collider.t10 * x + collider.t11 * y + collider.t12 * z) / $Precision
    world_z = (collider.t20 * x + collider.t21 * y + collider.t22 * z) / $Precision
    
    if translation
        world_x += collider.x
        world_y += collider.y
        world_z += collider.z
    end
end

function collider_world_to_local(x, y, z, translation)
    define name collider = "collider_$(collider)"

    if translation
        x -= collider.x
        y -= collider.y
        z -= collider.z
    end
    
    local_x = (collider.t00 * x + collider.t10 * y + collider.t20 * z) / $Precision
    local_y = (collider.t01 * x + collider.t11 * y + collider.t21 * z) / $Precision
    local_z = (collider.t02 * x + collider.t12 * y + collider.t22 * z) / $Precision
end

function collider_apply_impulse(x, y, z, ix, iy, iz)
    define name collider = "collider_$(collider)"
    
    collider.velocity_x += (ix * collider.inv_mass + $Half) / $Precision
    collider.velocity_y += (iy * collider.inv_mass + $Half) / $Precision
    collider.velocity_z += (iz * collider.inv_mass + $Half) / $Precision

    dx = x - collider.x
    dy = y - collider.y
    dz = z - collider.z
    
    axis_x = (dy * iz - dz * iy + $Half) / $Precision
    axis_y = (dz * ix - dx * iz + $Half) / $Precision
    axis_z = (dx * iy - dy * ix + $Half) / $Precision
    
    collider.rotation_x += (axis_x * collider.inv_rot_int) / $Precision
    collider.rotation_y += (axis_y * collider.inv_rot_int) / $Precision
    collider.rotation_z += (axis_z * collider.inv_rot_int) / $Precision
    
    if collider.sleeping
        collider_wake_up() with macros
    end
end

function collider_apply_spring_cable(spring_x, spring_y, spring_z, spring_neutral, spring_constant, local_att_x, local_att_y, local_att_z)
    define name collider = "collider_$(collider)"

    collider_local_to_world(local_att_x, local_att_y, local_att_z, True) with macros
    
    spring_dx = world_x - spring_x
    spring_dy = world_y - spring_y
    spring_dz = world_z - spring_z
    
    # Current length of the spring
    spring_mag = sqrt(spring_dx*spring_dx + spring_dy*spring_dy + spring_dz*spring_dz)
    
    # Spring displacement from neutral
    spring_disp = spring_mag - spring_neutral
    
    spring_dir_x = spring_dx * $Precision / spring_mag
    spring_dir_y = spring_dy * $Precision / spring_mag
    spring_dir_z = spring_dz * $Precision / spring_mag
    
    if spring_mag > spring_neutral
        force_x = -spring_dir_x * spring_disp / $Precision * spring_constant / $Precision
        force_y = -spring_dir_y * spring_disp / $Precision * spring_constant / $Precision
        force_z = -spring_dir_z * spring_disp / $Precision * spring_constant / $Precision
        
        collider_apply_impulse(world_x, world_y, world_z, force_x, force_y, force_z) with macros
    end
end

function collider_ray_intersection(x, y, z, dx, dy, dz)
    define name collider = "collider_$(collider)"

    collider_world_to_local(x, y, z, True) with macros
    local_origin_x = local_x
    local_origin_y = local_y
    local_origin_z = local_z
    
    collider_world_to_local(dx, dy, dz, False) with macros
    local_dx = local_x
    local_dy = local_y
    local_dz = local_z
    
    if local_dx == 0
        local_dx = 1
    end
    if local_dy == 0
        local_dy = 1
    end
    if local_dz == 0
        local_dz = 1
    end
    
    halfsize = collider.size / 2
    
    # Calculate the times of entry/exit along each axis
    txn = (-halfsize - local_origin_x) * $Precision / local_dx
    txp = (halfsize - local_origin_x) * $Precision / local_dx
    tyn = (-halfsize - local_origin_y) * $Precision / local_dy
    typ = (halfsize - local_origin_y) * $Precision / local_dy
    tzn = (-halfsize - local_origin_z) * $Precision / local_dz
    tzp = (halfsize - local_origin_z) * $Precision / local_dz
    
    # Figure out the minimum and maximum time along the x axis
    if txn > txp
        min_tx = txp
        max_tx = txn
        x_normal = $Precision
    else
        min_tx = txn
        max_tx = txp
        x_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the y axis
    if tyn > typ
        min_ty = typ
        max_ty = tyn
        y_normal = $Precision
    else
        min_ty = tyn
        max_ty = typ
        y_normal = -$Precision
    end
    
    # Figure out the minimum and maximum time along the z axis
    if tzn > tzp
        min_tz = tzp
        max_tz = tzn
        z_normal = $Precision
    else
        min_tz = tzn
        max_tz = tzp
        z_normal = -$Precision
    end
    
    # Figure out which axis we enter the cube last. Once the ray
    # has entered the cube along all 3 axes, it can collide.
    if min_tx > min_ty and min_tx > min_tz
        min_t = min_tx
        local_cnx = x_normal
        local_cny = 0
        local_cnz = 0
    else if min_ty > min_tz
        min_t = min_ty
        local_cnx = 0
        local_cny = y_normal
        local_cnz = 0
    else
        min_t = min_tz
        local_cnx = 0
        local_cny = 0
        local_cnz = z_normal
    end

    # Figure out which axis we exited the cube first. Once the ray
    # has exited the cube along any axis, it's no longer colliding.
    if max_tx < max_ty and max_tx < max_tz
        max_t = max_tx
    else if max_ty < max_tz
        max_t = max_ty
    else
        max_t = max_tz
    end
    
    # If the ray entered the cube along all three axes before it
    # exited along any axis, and it exited in front of us and not
    # behind us, then the ray intersections the cube, first hitting
    # it at t=min_t.
    if min_t < max_t and max_t > 0
        t = min_t
        
        if t < 0
            t = 0
        end
        
        local_cx = local_origin_x + t * local_dx / $Precision
        local_cy = local_origin_y + t * local_dy / $Precision
        local_cz = local_origin_z + t * local_dz / $Precision
        
        collider_local_to_world(local_cx, local_cy, local_cz, True) with macros
        collision_x = world_x
        collision_y = world_y
        collision_z = world_z
        
        collider_local_to_world(local_cnx, local_cny, local_cnz, False) with macros
        collision_nx = world_x
        collision_ny = world_y
        collision_nz = world_z
        
        return True
    else
        return False
    end
end

function initialize_vertex_adjacency()
    vertex_0_adj_1.val = 2
    vertex_0_adj_2.val = 4
    vertex_0_adj_3.val = 7

    vertex_1_adj_1.val = 3
    vertex_1_adj_2.val = 5
    vertex_1_adj_3.val = 6

    vertex_2_adj_1.val = 0
    vertex_2_adj_2.val = 5
    vertex_2_adj_3.val = 6

    vertex_3_adj_1.val = 1
    vertex_3_adj_2.val = 4
    vertex_3_adj_3.val = 7

    vertex_4_adj_1.val = 0
    vertex_4_adj_2.val = 3
    vertex_4_adj_3.val = 6

    vertex_5_adj_1.val = 1
    vertex_5_adj_2.val = 2
    vertex_5_adj_3.val = 7

    vertex_6_adj_1.val = 1
    vertex_6_adj_2.val = 2
    vertex_6_adj_3.val = 4

    vertex_7_adj_1.val = 0
    vertex_7_adj_2.val = 3
    vertex_7_adj_3.val = 5
end

function collider_calculate_vertex_world_positions()
    define name collider = "collider_$(collider)"
    
    halfsize = collider.size / 2
    
    # Initialized AABB
    collider.min_x = collider.x
    collider.min_y = collider.y
    collider.min_z = collider.z
    collider.max_x = collider.x
    collider.max_y = collider.y
    collider.max_z = collider.z
    
    for $vertex_pair in [[0, 1, 1, 1], [2, 1, -1, 1], [4, 1, 1, -1], [6, 1, -1, -1]]
        $i = $vertex_pair[0]
        $mx = $vertex_pair[1]
        $my = $vertex_pair[2]
        $mz = $vertex_pair[3]
        
        with
            $(vertex_pos) = $i
            $(vertex_neg) = $i + 1
        do
            define name collider_vertex_pos = "collider_$(collider)_v$(vertex_pos)"
            define name collider_vertex_neg = "collider_$(collider)_v$(vertex_neg)"
            
            collider_local_to_world(halfsize * $mx, halfsize * $my, halfsize * $mz, False) with macros
            collider_vertex_pos.x = collider.x + world_x
            collider_vertex_pos.y = collider.y + world_y
            collider_vertex_pos.z = collider.z + world_z
            
            collider_vertex_neg.x = collider.x - world_x
            collider_vertex_neg.y = collider.y - world_y
            collider_vertex_neg.z = collider.z - world_z
            
            # Expand AABB
            if collider_vertex_pos.x < collider.min_x
                collider.min_x = collider_vertex_pos.x
            end
            if collider_vertex_pos.y < collider.min_y
                collider.min_y = collider_vertex_pos.y
            end
            if collider_vertex_pos.z < collider.min_z
                collider.min_z = collider_vertex_pos.z
            end
            if collider_vertex_pos.x > collider.max_x
                collider.max_x = collider_vertex_pos.x
            end
            if collider_vertex_pos.y > collider.max_y
                collider.max_y = collider_vertex_pos.y
            end
            if collider_vertex_pos.z > collider.max_z
                collider.max_z = collider_vertex_pos.z
            end
            
            if collider_vertex_neg.x < collider.min_x
                collider.min_x = collider_vertex_neg.x
            end
            if collider_vertex_neg.y < collider.min_y
                collider.min_y = collider_vertex_neg.y
            end
            if collider_vertex_neg.z < collider.min_z
                collider.min_z = collider_vertex_neg.z
            end
            if collider_vertex_neg.x > collider.max_x
                collider.max_x = collider_vertex_neg.x
            end
            if collider_vertex_neg.y > collider.max_y
                collider.max_y = collider_vertex_neg.y
            end
            if collider_vertex_neg.z > collider.max_z
                collider.max_z = collider_vertex_neg.z
            end
        end
    end
end

function collider_physics_tick()
    define name collider = "collider_$(collider)"
    
    # Apply Gravity
    $Gravity = 45
    collider.velocity_y -= $Gravity
    
    collider_integrate() with macros
    collider_quaternion_to_transform() with macros
end

function resolve_collision_velocity()
    collision_frame++
    
    for vel_iter = 1 to 20
        max_closing = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"
            
                if collision.exists
                    with
                        $(collider1) = collision.collider1
                        $(collider2) = collision.collider2
                    update_closing_velocity()
                    
                    if collision.closing > max_closing
                        max_closing = collision.closing
                        max_closing_id = collision.id
                        max_closing_col1 = collision.collider1
                        max_closing_col2 = collision.collider2
                    end
                end
            end
        end
        
        if max_closing <= 5
            vel_iter = 1000000
        else
            with
                $(collision) = max_closing_id
                $(collider1) = max_closing_col1
                $(collider2) = max_closing_col2
            handle_collision_impulse()
        end
    end
end

function update_closing_velocity()
    define name collision = "collision_$(collision)"
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    
    /scoreboard players set Global twobody $(collider2)
    
    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z

    rot_lin_vel_x = (collider1.rotation_y * dz - collider1.rotation_z * dy + $Half) / $Precision
    rot_lin_vel_y = (collider1.rotation_z * dx - collider1.rotation_x * dz + $Half) / $Precision
    rot_lin_vel_z = (collider1.rotation_x * dy - collider1.rotation_y * dx + $Half) / $Precision
    
    collision.vel_x = collider1.velocity_x + rot_lin_vel_x
    collision.vel_y = collider1.velocity_y + rot_lin_vel_y
    collision.vel_z = collider1.velocity_z + rot_lin_vel_z

    if twobody
        dx = collision.x - collider2.x
        dy = collision.y - collider2.y
        dz = collision.z - collider2.z

        rot_lin_vel_x = (collider2.rotation_y * dz - collider2.rotation_z * dy + $Half) / $Precision
        rot_lin_vel_y = (collider2.rotation_z * dx - collider2.rotation_x * dz + $Half) / $Precision
        rot_lin_vel_z = (collider2.rotation_x * dy - collider2.rotation_y * dx + $Half) / $Precision
        
        collision.vel_x -= collider2.velocity_x + rot_lin_vel_x
        collision.vel_y -= collider2.velocity_y + rot_lin_vel_y
        collision.vel_z -= collider2.velocity_z + rot_lin_vel_z

    end
    
    collision.closing = -(collision.vel_x * collision.nx + collision.vel_y * collision.ny + collision.vel_z * collision.nz + $Half) / $Precision
end

function resolve_collision_penetration()
    for pen_iter = 1 to 20
        max_pen = 0
        
        for collision = 1 to max_collision
            with
                $(collision) = collision
            do
                define name collision = "collision_$(collision)"

                if collision.exists and collision.pen > max_pen
                    max_pen = collision.pen
                    max_pen_nx = collision.nx
                    max_pen_ny = collision.ny
                    max_pen_nz = collision.nz
                    max_pen_col1 = collision.collider1
                    max_pen_col2 = collision.collider2
                end
            end
        end
        
        if max_pen <= 5
            pen_iter = 1000000
        else
            mx = (max_pen_nx * max_pen) / $Precision
            my = (max_pen_ny * max_pen) / $Precision
            mz = (max_pen_nz * max_pen) / $Precision
            
            #tell @a "Resolving (max_pen_col1) and (max_pen_col2) with pen (max_pen), moving (mx), (my), (mz)"
            
            if max_pen_col2 == -1
                with
                    $(collider) = max_pen_col1
                do
                    define name collider = "collider_$(collider)"
        
                    collider.x += mx
                    collider.y += my
                    collider.z += mz
                    
                    move_collisions(mx, my, mz, collider.id)
                end
            else
                with
                    $(collider1) = max_pen_col1
                    $(collider2) = max_pen_col2
                do
                    define name collider1 = "collider_$(collider1)"
                    define name collider2 = "collider_$(collider2)"
                    
                    inv_mass = collider1.inv_mass + collider2.inv_mass

                    p1 = collider1.inv_mass * $Precision / inv_mass
                    
                    m1x = p1 * mx / $Precision
                    m1y = p1 * my / $Precision
                    m1z = p1 * mz / $Precision
        
                    collider1.x += m1x 
                    collider1.y += m1y
                    collider1.z += m1z
                    if collider1.sleeping
                        with
                            $(collider) = collider1.id
                        collider_wake_up()
                    end
                    
                    move_collisions(m1x, m1y, m1z, collider1.id)
                    
                    p2 = -collider2.inv_mass * $Precision / inv_mass
                    
                    m2x = p2 * mx / $Precision
                    m2y = p2 * my / $Precision
                    m2z = p2 * mz / $Precision
        
                    collider2.x += m2x 
                    collider2.y += m2y
                    collider2.z += m2z
                    if collider2.sleeping
                        with
                            $(collider) = collider2.id
                        collider_wake_up()
                    end
                    
                    move_collisions(m2x, m2y, m2z, collider2.id)
                end
            end
        end
    end
end

function move_collisions(dx, dy, dz, collider)
    for collision = 1 to max_collision
        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
    
            if collision.exists
                do_move = False
                if collision.collider1 == collider
                    do_move = True
                    sign = 1
                end
                if collision.collider2 == collider
                    do_move = True
                    sign = -1
                end
                
                if do_move
                    collision.pen -= sign * (dx*collision.nx + dy*collision.ny + dz*collision.nz) / $Precision
                end
            end
        end
    end
end

function is_air()
    air = False
    /execute if block $(x) $(y) $(z) minecraft:air run scoreboard players set Global air 1
end

function get_collisions()
    define name collider = "collider_$(collider)"
    
    collider_calculate_vertex_world_positions() with macros

    for vertex = 0 to 7
        with
            $(vertex) = vertex
        do
            define name v = "collider_$(collider)_v$(vertex)"
            
            with
                $(x) = v.x / $Precision
                $(y) = v.y / $Precision
                $(z) = v.z / $Precision
            is_air()
            
            if not air
                block_x = v.x % $Precision
                block_y = v.y % $Precision
                block_z = v.z % $Precision
                nblock_x = $Precision - block_x
                nblock_y = $Precision - block_y
                nblock_z = $Precision - block_z
                
                min_pen = 1000
                
                if nblock_y < min_pen
                    with
                        $(y) = v.y / $Precision + 1
                    is_air()
                    
                    if air
                        min_pen = nblock_y
                        nx = 0
                        ny = $Precision
                        nz = 0
                    end
                end

                if block_y < min_pen
                    with
                        $(y) = v.y / $Precision - 1
                    is_air()
                    
                    if air
                        min_pen = block_y
                        nx = 0
                        ny = -$Precision
                        nz = 0
                    end
                end
                
                if nblock_x < min_pen
                    with
                        $(x) = v.x / $Precision + 1
                        $(y) = v.y / $Precision
                    is_air()

                    if air
                        min_pen = nblock_x
                        nx = $Precision
                        ny = 0
                        nz = 0
                    end
                end

                if block_x < min_pen
                    with
                        $(x) = v.x / $Precision - 1
                        $(y) = v.y / $Precision
                    is_air()
                    
                    if air
                        min_pen = block_x
                        nx = -$Precision
                        ny = 0
                        nz = 0
                    end
                end

                if nblock_z < min_pen
                    with
                        $(x) = v.x / $Precision
                        $(y) = v.y / $Precision
                        $(z) = v.z / $Precision + 1
                    is_air()
                    
                    if air
                        min_pen = nblock_z
                        nx = 0
                        ny = 0
                        nz = $Precision
                    end
                end
                
                if block_z < min_pen
                    with
                        $(x) = v.x / $Precision
                        $(y) = v.y / $Precision
                        $(z) = v.z / $Precision - 1
                    is_air()
                    
                    if air
                        min_pen = block_z
                        nx = 0
                        ny = 0
                        nz = -$Precision
                    end
                end
                
                if min_pen < 1000
                    create_collision(v.x, v.y, v.z, nx, ny, nz, min_pen, collider.id, -1)
                end
            end
        end
    end
    
    # Check each world geometry block corner to see if there's a block there,
    # and if so, whether it collides.
    start_x = (collider.min_x/$Precision+1)*$Precision
    start_y = (collider.min_y/$Precision+1)*$Precision
    start_z = (collider.min_z/$Precision+1)*$Precision
    
    for block_x = start_x to collider.max_x by $Precision
        for block_y = start_y to collider.max_y by $Precision
            for block_z = start_z to collider.max_z by $Precision
            
                for dx = -1 to 0
                    for dy = -1 to 0
                        for dz = -1 to 0
                            with
                                $(x) = block_x / $Precision + dx
                                $(y) = block_y / $Precision + dy
                                $(z) = block_z / $Precision + dz
                            is_air()
                            
                            if not air
                                dx = 2
                                dy = 2
                                dz = 2
                            end
                        end
                    end
                end
                
                if not air
                    collider_world_to_local(block_x, block_y, block_z, True) with macros
                    if local_x > -collider.halfsize and local_x < collider.halfsize and local_y > -collider.halfsize and local_y < collider.halfsize and local_z > -collider.halfsize and local_z < collider.halfsize
                        min_pen = collider.halfsize
                        
                        pen = collider.halfsize + local_x
                        if pen < min_pen
                            min_pen = pen
                            lnx = $Precision
                            lny = 0
                            lnz = 0
                        end
                        
                        pen = collider.halfsize - local_x
                        if pen < min_pen
                            min_pen = pen
                            lnx = -$Precision
                            lny = 0
                            lnz = 0
                        end
                        
                        pen = collider.halfsize + local_y
                        if pen < min_pen
                            min_pen = pen
                            lnx = 0
                            lny = $Precision
                            lnz = 0
                        end
                        
                        pen = collider.halfsize - local_y
                        if pen < min_pen
                            min_pen = pen
                            lnx = 0
                            lny = -$Precision
                            lnz = 0
                        end
                        
                        pen = collider.halfsize + local_z
                        if pen < min_pen
                            min_pen = pen
                            lnx = 0
                            lny = 0
                            lnz = $Precision
                        end
                        
                        pen = collider.halfsize - local_z
                        if pen < min_pen
                            min_pen = pen
                            lnx = 0
                            lny = 0
                            lnz = -$Precision
                        end

                        if min_pen < collider.halfsize
                            collider_local_to_world(lnx, lny, lnz, False) with macros
                            
                            create_collision(block_x, block_y, block_z, world_x, world_y, world_z, min_pen, collider.id, -1)
                        end
                    end
                end
            end
        end
    end
end

function get_edge_world_collisions()
    for $edge in [[0, 2], [1, 3], [0, 4], [1, 5], [2, 6], [3, 7], [4, 6], [5, 7], [0, 7], [2, 5], [4, 3], [6, 1]]
        $vertex1 = $edge[0]
        $vertex2 = $edge[1]
        with
            $(vertex) = $vertex1
        get_origin_vertex()
        
        with
            $(vertex) = $vertex2
        get_dest_vertex()
        
        raymarch_edge() with macros
    end
end

function get_origin_vertex()
    define name v = "collider_$(collider)_v$(vertex)"
    ox = v.x
    oy = v.y
    oz = v.z
end

function get_dest_vertex()
    define name v = "collider_$(collider)_v$(vertex)"
    destx = v.x
    desty = v.y
    destz = v.z
end

# Assumes ox, oy, oz and destx, desty, destz are the two vertices in world coordinates.        
function raymarch_edge()
    define name collider = "collider_$(collider)"
    
    ex = (destx - ox) * $Precision / collider.size
    ey = (desty - oy) * $Precision / collider.size
    ez = (destz - oz) * $Precision / collider.size
    
    if ex == 0
        ex = 1
    end
    if ey == 0
        ey = 1
    end
    if ez == 0
        ez = 1
    end
    
    if ex < 0
        next_x = ox / $Precision * $Precision
    else
        next_x = (ox / $Precision + 1) * $Precision
    end
    if ey < 0
        next_y = oy / $Precision * $Precision
    else
        next_y = (oy / $Precision + 1) * $Precision
    end
    if ez < 0
        next_z = oz / $Precision * $Precision
    else
        next_z = (oz / $Precision + 1) * $Precision
    end
    
    t = 0
    x = ox
    y = oy
    z = oz
    prev_t = 0
    failsafe = 0
    $X_Axis = 0
    $Y_Axis = 1
    $Z_Axis = 2
    
    while t < collider.size and failsafe < 50
        failsafe++
        next_x_t = (next_x - ox) * $Precision / ex
        next_y_t = (next_y - oy) * $Precision / ey
        next_z_t = (next_z - oz) * $Precision / ez
        
        if next_x_t < next_y_t and next_x_t < next_z_t
            # Crosses at x next
            t = next_x_t
            x = next_x
            y = oy + t * ey / $Precision
            z = oz + t * ez / $Precision
            crossing = $X_Axis
            
            if ex < 0
                next_x -= $Precision
            else
                next_x += $Precision
            end
            
            next_x_t = (next_x - ox) * $Precision / ex
        else if next_y_t < next_z_t
            # Crosses at y next
            t = next_y_t
            x = ox + t * ex / $Precision
            y = next_y
            z = oz + t * ez / $Precision
            crossing = $Y_Axis
            
            if ey < 0
                next_y -= $Precision
            else
                next_y += $Precision
            end
            
            next_y_t = (next_y - oy) * $Precision / ey
        else
            # Crosses at z next
            t = next_z_t
            x = ox + t * ex / $Precision
            y = oy + t * ey / $Precision
            z = next_z
            crossing = $Z_Axis
            
            if ez < 0
                next_z -= $Precision
            else
                next_z += $Precision
            end
            
            next_z_t = (next_z - oz) * $Precision / ez
        end
        
        if t < collider.size and prev_t > 0
            if x < prev_x
                block_x = x / $Precision * $Precision
            end                    
            if x >= prev_x
                block_x = prev_x / $Precision * $Precision
            end
            if y < prev_y
                block_y = y / $Precision * $Precision
            end                    
            if y >= prev_y
                block_y = prev_y / $Precision * $Precision
            end
            if z < prev_z
                block_z = z / $Precision * $Precision
            end                    
            if z >= prev_z
                block_z = prev_z / $Precision * $Precision
            end
            
            @Position.<pos> = <block_x, block_y, block_z>
            
            at @Position
                with
                    $(x) = block_x / $Precision
                    $(y) = block_y / $Precision
                    $(z) = block_z / $Precision
                is_air()
                
                if not air
                    # Edge is penetrating a block                            
                    closest = $Precision
                    
                    if prev_crossing == $X_Axis
                        
                        empty = False
                        if ex > 0 and block ~-1 ~ ~ air
                            empty = True
                        end
                        if ex <= 0 and block ~1 ~ ~ air
                            empty = True
                        end
                        
                        if empty
                            offy = prev_y % $Precision
                            offz = prev_z % $Precision
                            noffy = $Precision - offy
                            noffz = $Precision - offz
                            
                            if offy < closest and block ~ ~-1 ~ air
                                closest = offy
                                cox = prev_x
                                coy = prev_y / $Precision * $Precision
                                coz = prev_z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if noffy < closest and block ~ ~1 ~ air
                                closest = noffy
                                cox = prev_x
                                coy = (prev_y / $Precision + 1) * $Precision
                                coz = prev_z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if offz < closest and block ~ ~ ~-1 air
                                closest = offz
                                cox = prev_x
                                coy = prev_y / $Precision * $Precision
                                coz = prev_z / $Precision * $Precision
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if noffz < closest and block ~ ~ ~1 air
                                closest = noffz
                                cox = prev_x
                                coy = prev_y / $Precision * $Precision
                                coz = (prev_z / $Precision + 1) * $Precision
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                        end
                    end
                    if crossing == $X_Axis
                        empty = False
                        if ex > 0 and block ~1 ~ ~ air
                            empty = True
                        end
                        if ex <= 0 and block ~-1 ~ ~ air
                            empty = True
                        end
                        
                        if empty
                            offy = y % $Precision
                            offz = z % $Precision
                            noffy = $Precision - offy
                            noffz = $Precision - offz
                            
                            if offy < closest and block ~ ~-1 ~ air
                                closest = offy
                                cox = x
                                coy = y / $Precision * $Precision
                                coz = z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if noffy < closest and block ~ ~1 ~ air
                                closest = noffy
                                cox = x
                                coy = (y / $Precision + 1) * $Precision
                                coz = z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if offz < closest and block ~ ~ ~-1 air
                                closest = offz
                                cox = x
                                coy = y / $Precision * $Precision
                                coz = z / $Precision * $Precision
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if noffz < closest and block ~ ~ ~1 air
                                closest = noffz
                                cox = x
                                coy = y / $Precision * $Precision
                                coz = (z / $Precision + 1) * $Precision
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                        end
                    end

                    if prev_crossing == $Y_Axis
                        empty = False
                        if ey > 0 and block ~ ~-1 ~ air
                            empty = True
                        end
                        if ey <= 0 and block ~ ~1 ~ air
                            empty = True
                        end
                        
                        if empty
                            offx = prev_x % $Precision
                            offz = prev_z % $Precision
                            noffx = $Precision - offx
                            noffz = $Precision - offz
                            
                            if offx < closest and block ~-1 ~ ~ air
                                closest = offx
                                cox = prev_x / $Precision * $Precision
                                coy = prev_y
                                coz = prev_z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if noffx < closest and block ~1 ~ ~ air
                                closest = noffx
                                cox = (prev_x / $Precision + 1) * $Precision
                                coy = prev_y
                                coz = prev_z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if offz < closest and block ~ ~ ~-1 air
                                closest = offz
                                cox = prev_x / $Precision * $Precision
                                coy = prev_y
                                coz = prev_z / $Precision * $Precision
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                            if noffz < closest and block ~ ~ ~1 air
                                closest = noffz
                                cox = prev_x / $Precision * $Precision
                                coy = prev_y
                                coz = (prev_z / $Precision + 1) * $Precision
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                        end
                    end
                    if crossing == $Y_Axis
                        empty = False
                        if ey > 0 and block ~ ~1 ~ air
                            empty = True
                        end
                        if ey <= 0 and block ~ ~-1 ~ air
                            empty = True
                        end
                        
                        if empty
                            offx = x % $Precision
                            offz = z % $Precision
                            noffx = $Precision - offx
                            noffz = $Precision - offz
                            
                            if offx < closest and block ~-1 ~ ~ air
                                closest = offx
                                cox = x / $Precision * $Precision
                                coy = y
                                coz = z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if noffx < closest and block ~1 ~ ~ air
                                closest = noffx
                                cox = (x / $Precision + 1) * $Precision
                                coy = y
                                coz = z / $Precision * $Precision
                                cex = 0
                                cey = 0
                                cez = $Precision
                            end
                            if offz < closest and block ~ ~ ~-1 air
                                closest = offz
                                cox = x / $Precision * $Precision
                                coy = y
                                coz = z / $Precision * $Precision
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                            if noffz < closest and block ~ ~ ~1 air
                                closest = noffz
                                cox = x / $Precision * $Precision
                                coy = y
                                coz = (z / $Precision + 1) * $Precision
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                        end
                    end
                    
                    if prev_crossing == $Z_Axis
                        empty = False
                        if ez > 0 and block ~ ~ ~-1 air
                            empty = True
                        end
                        if ez <= 0 and block ~ ~ ~1 air
                            empty = True
                        end
                        
                        if empty
                            offx = prev_x % $Precision
                            offy = prev_y % $Precision
                            noffx = $Precision - offx
                            noffy = $Precision - offy
                            
                            if offx < closest and block ~-1 ~ ~ air
                                closest = offx
                                cox = prev_x / $Precision * $Precision
                                coy = prev_y / $Precision * $Precision
                                coz = prev_z
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if noffx < closest and block ~1 ~ ~ air
                                closest = noffx
                                cox = (prev_x / $Precision + 1) * $Precision
                                coy = prev_y / $Precision * $Precision
                                coz = prev_z
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if offy < closest and block ~ ~-1 ~ air
                                closest = offy
                                cox = prev_x / $Precision * $Precision
                                coy = prev_y / $Precision * $Precision
                                coz = prev_z
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                            if noffy < closest and block ~ ~1 ~ air
                                closest = noffy
                                cox = prev_x / $Precision * $Precision
                                coy = (prev_y / $Precision + 1) * $Precision
                                coz = prev_z
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                        end
                    end
                    if crossing == $Z_Axis
                        empty = False
                        if ez > 0 and block ~ ~ ~1 air
                            empty = True
                        end
                        if ez <= 0 and block ~ ~ ~-1 air
                            empty = True
                        end
                        
                        if empty
                            offx = x % $Precision
                            offy = y % $Precision
                            noffx = $Precision - offx
                            noffy = $Precision - offy
                            
                            if offx < closest and block ~-1 ~ ~ air
                                closest = offx
                                cox = x / $Precision * $Precision
                                coy = y / $Precision * $Precision
                                coz = z
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if noffx < closest and block ~1 ~ ~ air
                                closest = noffx
                                cox = (x / $Precision + 1) * $Precision
                                coy = y / $Precision * $Precision
                                coz = z
                                cex = 0
                                cey = $Precision
                                cez = 0
                            end
                            if offy < closest and block ~ ~-1 ~ air
                                closest = offy
                                cox = x / $Precision * $Precision
                                coy = y / $Precision * $Precision
                                coz = z
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                            if noffy < closest and block ~ ~1 ~ air
                                closest = noffy
                                cox = x / $Precision * $Precision
                                coy = (y / $Precision + 1) * $Precision
                                coz = z
                                cex = $Precision
                                cey = 0
                                cez = 0
                            end
                        end
                    end
                    
                    if closest < $Precision
                        get_edge_edge_penetration(ox, oy, oz, ex, ey, ez, cox, coy, coz, cex, cey, cez)
                        
                        # Check if the collision point is inside the block
                        if p1x >= block_x and p1x < block_x + $Precision and p1y >= block_y and p1y < block_y + $Precision and p1z >= block_z and p1z < block_z + $Precision
                            # Direction from collider center to the collision point
                            dx = p1x - collider.x
                            dy = p1y - collider.y
                            dz = p1z - collider.z

                            # Dot product of that direction and the collision normal
                            normdir = dx*nx + dy*ny + dz*nz
                            
                            if normdir > 0
                                # Make sure the collision normal points towards the collider (away from the block)
                                nx *= -1
                                ny *= -1
                                nz *= -1
                            end

                            # Make sure the penetration is positive
                            if d < 0
                                d *= -1
                            end

                            # Cap the penetration
                            if d > 200
                                d = 200
                            end
                        
                            create_collision(p1x, p1y, p1z, nx, ny, nz, d, collider.id, -1)
                        end
                    end
                end
            end
        end
        
        prev_t = t
        prev_x = x
        prev_y = y
        prev_z = z
        prev_crossing = crossing
    end
end

# Source for the math: https://math.stackexchange.com/questions/2213165/find-shortest-distance-between-lines-in-3d
function get_edge_edge_penetration(o1x, o1y, o1z, d1x, d1y, d1z, o2x, o2y, o2z, d2x, d2y, d2z)
    # Cross the two directions to get the normal
    nx = (d1y * d2z - d1z * d2y) / $Precision
    ny = (d1z * d2x - d1x * d2z) / $Precision
    nz = (d1x * d2y - d1y * d2x) / $Precision

    # Get the magnitude and square magnitude
    nmagsq = nx*nx + ny*ny + nz*nz
    nmag = sqrt(nmagsq)
    
    # Difference of origins
    odx = o2x - o1x
    ody = o2y - o1y
    odz = o2z - o1z

    # Get the distance
    d = (nx * odx + ny * ody + nz * odz) / nmag
    
    # Get a vector perpendicular to the normal and the second ray
    # These are scaled up by the Precision because it'll be divided
    # out in the next step
    perpx_big = d2y * nz - d2z * ny
    perpy_big = d2z * nx - d2x * nz
    perpz_big = d2x * ny - d2y * nx
    
    # Get the projected distance along the first ray
    t = (perpx_big * odx + perpy_big * ody + perpz_big * odz) / nmagsq
    
    # Get the point on the first ray
    p1x = o1x + t * d1x / $Precision
    p1y = o1y + t * d1y / $Precision
    p1z = o1z + t * d1z / $Precision

    # Normalize the normal
    nx *= $Precision
    ny *= $Precision
    nz *= $Precision
    nx /= nmag
    ny /= nmag
    nz /= nmag
end

function get_collider_collider_collisions()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    
    if collider1.sleeping and collider2.sleeping

    else
        dx = collider2.x - collider1.x
        dy = collider2.y - collider1.y
        dz = collider2.z - collider1.z
        
        total_hsize = collider1.halfsize + collider2.halfsize
        
        # Mulitply by sqrt(3) to account for bounding spheres
        total_hsize *= 1732
        total_hsize /= $Precision
        
        distsq = (dx*dx + dy*dy + dz*dz) / $Precision
        total_hsize_sq = total_hsize*total_hsize / $Precision
        
        if distsq <= total_hsize_sq
            with
                $(col1) = collider1.id
                $(col2) = collider2.id
            get_point_face_collisions()
            
            with
                $(col1) = collider2.id
                $(col2) = collider1.id
            get_point_face_collisions()
            
            get_collider_edge_collider_edge_collisions() with macros
        end
    end
end

function get_point_face_collisions()
    define name collider1 = "collider_$(col1)"
    define name collider2 = "collider_$(col2)"
    
    for vertex = 0 to 7
        with
            $(vertex) = vertex
        do
            define name vertex = "collider_$(col2)_v$(vertex)"
            
            dx = vertex.x - collider1.x
            dy = vertex.y - collider1.y
            dz = vertex.z - collider1.z
            distsq = (dx*dx + dy*dy + dz*dz) / $Precision
            
            sizesq = collider1.halfsize * collider1.halfsize / $Precision
            
            # Muliply by sqrt(3) to account for bounding spheres
            sizesq *= 1732
            sizesq /= $Precision
            
            if distsq <= sizesq
                with
                    $(collider) = collider1.id
                collider_world_to_local(vertex.x, vertex.y, vertex.z, True)
                
                absx = local_x
                signx = -$Precision
                if absx < 0
                    absx *= -1
                    signx *= -1
                end
                
                absy = local_y
                signy = -$Precision
                if absy < 0
                    absy *= -1
                    signy *= -1
                end
                
                absz = local_z
                signz = -$Precision
                if absz < 0
                    absz *= -1
                    signz *= -1
                end
                
                if absx < collider1.halfsize and absy < collider1.halfsize and absz < collider1.halfsize
                    if absx > absy and absx > absz
                        pen = collider1.halfsize - absx
                        nx = signx
                        ny = 0
                        nz = 0
                    else if absy > absz
                        pen = collider1.halfsize - absy
                        nx = 0
                        ny = signy
                        nz = 0
                    else
                        pen = collider1.halfsize - absz
                        nx = 0
                        ny = 0
                        nz = signz
                    end
                    
                    with
                        $(collider) = collider1.id
                    collider_local_to_world(nx, ny, nz, False)
                    
                    #tell @a "(collider1.id) collided with (collider2.id) at (vertex.x), (vertex.y), (vertex.z) norm (world_x), (world_y), (world_z), pen (pen)"
                    create_collision(vertex.x, vertex.y, vertex.z, world_x, world_y, world_z, pen, collider1.id, collider2.id)
                end
            end
        end
    end
end
function get_collider_edge_collider_edge_collisions()
    define name collider1 = "collider_$(col1)"
    define name collider2 = "collider_$(col2)"
    
    with
        $(ncol1) = collider1.id
        $(ncol2) = collider2.id
    get_nearest_vertex()
    vertex1 = vertex
    
    with
        $(ncol1) = collider2.id
        $(ncol2) = collider1.id
    get_nearest_vertex()
    vertex2 = vertex
    
    with
        $(vertex) = vertex1
    do
        define name vertex = "collider_$(col1)_v$(vertex)"
        o1x = vertex.x
        o1y = vertex.y
        o1z = vertex.z
    end

    with
        $(vertex) = vertex2
    do
        define name vertex = "collider_$(col2)_v$(vertex)"
        o2x = vertex.x
        o2y = vertex.y
        o2z = vertex.z
    end
    
    min_pen = $Precision
    
    for neighbor1 = 1 to 3
        with
            $(neighbor) = neighbor1
            $(vertex) = vertex1
        do
            define name neighbor = "vertex_$(vertex)_adj_$(neighbor)"
            nvert = neighbor.val
        end
        with
            $(vertex) = nvert
        do
            define name vertex = "collider_$(col1)_v$(vertex)"
            d1x = vertex.x - o1x
            d1y = vertex.y - o1y
            d1z = vertex.z - o1z
        end
    
        for neighbor2 = 1 to 3
            with
                $(neighbor) = neighbor2
                $(vertex) = vertex2
            do
                define name neighbor = "vertex_$(vertex)_adj_$(neighbor)"
                nvert = neighbor.val
            end
            with
                $(vertex) = nvert
            do
                define name vertex = "collider_$(col2)_v$(vertex)"
                d2x = vertex.x - o2x
                d2y = vertex.y - o2y
                d2z = vertex.z - o2z
            end
            
            get_edge_edge_penetration(o1x, o1y, o1z, d1x, d1y, d1z, o2x, o2y, o2z, d2x, d2y, d2z)
            
            if t >= 0 and t <= $Precision
                # The collision falls along the collider1 edge
                
                dx = p1x - collider1.x
                dy = p1y - collider1.y
                dz = p1z - collider1.z
                
                # Check if the normal vector is pointing in the same
                # direction as the collision point from the origin
                dot = dx*nx + dy*ny + dz*nz
                
                penetrating = False
                if dot < 0 and d > 0
                    # Normal vector pointing toward origin, and positive distance
                    penetrating = True
                end
                
                if dot > 0 and d < 0
                    # Normal vector pointing away from origin, and negative distance
                    penetrating = True
                    nx *= -1
                    ny *= -1
                    nz *= -1
                    d *= -1
                end
                
                with
                    $(collider) = collider2.id
                collider_world_to_local(p1x, p1y, p1z, True)
                if local_x >= -collider2.halfsize and local_x <= collider2.halfsize and local_y >= -collider2.halfsize and local_y <= collider2.halfsize and local_z >= -collider2.halfsize and local_z <= collider2.halfsize                
                    # The collision point falls within collider2
                    if penetrating and d < min_pen
                        min_pen = d
                        min_x = p1x
                        min_y = p1y
                        min_z = p1z
                        min_nx = nx
                        min_ny = ny
                        min_nz = nz
                    end
                end
            end
        end        
    end
    
    if min_pen < $Precision
        #tell @a "(collider1.id) hit (collider2.id) at (min_x), (min_y), (min_z) norm (min_nx), (min_ny), (min_nz) pen (min_pen)"
        create_collision(min_x, min_y, min_z, min_nx, min_ny, min_nz, min_pen, collider1.id, collider2.id)
    end
end

function get_nearest_vertex()
    define name collider1 = "collider_$(ncol1)"
    define name collider2 = "collider_$(ncol2)"
    
    with
        $(collider) = collider1.id
    collider_world_to_local(collider2.x, collider2.y, collider2.z, True)
    
    if local_x > 0
        if local_y > 0
            if local_z > 0
                vertex = 0
            end
            if local_z < 0
                vertex = 4
            end
        end
        if local_y < 0
            if local_z > 0
                vertex = 2
            end
            if local_z < 0
                vertex = 6
            end
        end
    end
    if local_x < 0
        if local_y > 0
            if local_z > 0
                vertex = 7
            end
            if local_z < 0
                vertex = 3
            end
        end
        if local_y < 0
            if local_z > 0
                vertex = 5
            end
            if local_z < 0
                vertex = 1
            end
        end
    end
end

function create_collision(x, y, z, nx, ny, nz, pen, collider1, collider2)
    id = get_unused_collision_id()

    with
        $(collision) = id
    do
        define name collision = "collision_$(collision)"
        
        /scoreboard players set collision_$(collision) id $(collision)
        collision.exists = True
        collision.x = x
        collision.y = y
        collision.z = z
        
        collision.nx = nx
        collision.ny = ny
        collision.nz = nz
        
        collision.pen = pen
        
        collision.collider1 = collider1
        collision.collider2 = collider2
        
        if collision.id > max_collision
            max_collision = collision.id
        end    
    end
end

function get_unused_collision_id()
    unused_id = -1

    for collision = collision_start to 200
        exists = False

        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            unless collision.exists
                collision_start = collision + 1
                unused_id = collision
                collision = 1000000
            end
        end
    end
    
    return unused_id
end

function delete_collisions()
    for collision = 1 to max_collision
        with
            $(collision) = collision
        do
            define name collision = "collision_$(collision)"
            if collision.exists
                if collision.id < collision_start
                    collision_start = collision.id
                end

                /scoreboard players reset collision_$(collision)
            end
        end        
        
    end
    
    max_collision = 0
    collision_start = 1
end

# Initializes contact transform, and impulse <--> velocity matrices
function initialize_collision_matrices()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"

    # Create contact basis/transform
    collision.ct_01 = collision.nx
    collision.ct_11 = collision.ny
    collision.ct_21 = collision.nz
    
    absx = abs(collision.nx)
    absz = abs(collision.nz)
    
    if absx < absz
        # The norm isn't pointing toward x, so
        # cross the norm with 1,0,0
        s = sqrt(collision.ny*collision.ny + collision.nz*collision.nz)
        collision.ct_00 = 0
        collision.ct_10 = -collision.nz * $Precision / s
        collision.ct_20 = collision.ny * $Precision / s

        # Cross the norm with the new vector
        collision.ct_02 = (collision.ct_10*collision.ct_21 - collision.ct_20*collision.ct_11) / $Precision
        collision.ct_12 = (collision.ct_20*collision.ct_01) / $Precision
        collision.ct_22 = (collision.ct_10*collision.ct_01) / $Precision
    else
        # The norm isn't pointing toward z, so
        # cross the norm with 0,0,1
        s = sqrt(collision.ny*collision.ny + collision.nx*collision.nx)
        collision.ct_00 = collision.ny * $Precision / s
        collision.ct_10 = -collision.nx * $Precision / s
        collision.ct_20 = 0

        # Cross the norm with the new vector
        collision.ct_02 = (collision.ct_10*collision.ct_21) / $Precision
        collision.ct_12 = (collision.ct_00*collision.ct_21) / $Precision
        collision.ct_22 = (collision.ct_00*collision.ct_11 - collision.ct_10*collision.ct_01) / $Precision
    end

    dx = collision.x - collider1.x
    dy = collision.y - collider1.y
    dz = collision.z - collider1.z
    
    # Impulse to velocity transform
    # Formula: -(i_to_t^2) * InverseRotationalIntertia
    i_to_v_00 = ((dz * dz + dy * dy) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_01 = ((-dy * dx) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_02 = ((-dz * dx) / $Precision * collider1.inv_rot_int) / $Precision

    i_to_v_10 = ((-dx * dy) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_11 = ((dz * dz + dx * dx) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_12 = ((-dz * dy) / $Precision * collider1.inv_rot_int) / $Precision

    i_to_v_20 = ((-dx * dz) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_21 = ((-dy * dz) / $Precision * collider1.inv_rot_int) / $Precision
    i_to_v_22 = ((dy * dy + dx * dx) / $Precision * collider1.inv_rot_int) / $Precision
    
    # Transform i_to_v into contact coordinates before inverting,
    # using change of basis formula
    
    # First, ct^transpose * i_to_v
    with
        $(m1) = "collision_$(collision) ct"
        $(m2) = "Global i_to_v"
        $(out) = "Global m"
    transpose_matrix_multiply()

    # Then, multiply by ct
    with
        $(m1) = "Global m"
        $(m2) = "collision_$(collision) ct"
        $(out) = "collision_$(collision) c_i_to_v"
    matrix_multiply()
    
    inv_mass = collider1.inv_mass
    
    if twobody
        dx = collision.x - collider2.x
        dy = collision.y - collider2.y
        dz = collision.z - collider2.z

        # Impulse to velocity transform
        # Formula: -(i_to_t^2) * InverseRotationalIntertia
        i_to_v_00 = ((dz * dz + dy * dy) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_01 = ((-dy * dx) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_02 = ((-dz * dx) / $Precision * collider2.inv_rot_int) / $Precision

        i_to_v_10 = ((-dx * dy) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_11 = ((dz * dz + dx * dx) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_12 = ((-dz * dy) / $Precision * collider2.inv_rot_int) / $Precision

        i_to_v_20 = ((-dx * dz) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_21 = ((-dy * dz) / $Precision * collider2.inv_rot_int) / $Precision
        i_to_v_22 = ((dy * dy + dx * dx) / $Precision * collider2.inv_rot_int) / $Precision
        
        # Transform i_to_v into contact coordinates before inverting,
        # using change of basis formula
        
        # First, ct^transpose * i_to_v
        with
            $(m1) = "collision_$(collision) ct"
            $(m2) = "Global i_to_v"
            $(out) = "Global m"
        transpose_matrix_multiply()

        # Then, multiply by ct
        with
            $(m1) = "Global m"
            $(m2) = "collision_$(collision) ct"
            $(out) = "Global c_i_to_v_2"
        matrix_multiply()
        
        collision.c_i_to_v_00 += c_i_to_v_2_00
        collision.c_i_to_v_01 += c_i_to_v_2_01
        collision.c_i_to_v_02 += c_i_to_v_2_02
        collision.c_i_to_v_10 += c_i_to_v_2_10
        collision.c_i_to_v_11 += c_i_to_v_2_11
        collision.c_i_to_v_12 += c_i_to_v_2_12
        collision.c_i_to_v_20 += c_i_to_v_2_20
        collision.c_i_to_v_21 += c_i_to_v_2_21
        collision.c_i_to_v_22 += c_i_to_v_2_22
        
        inv_mass += collider2.inv_mass
    end
    
    # In contact space, add the inverse mass to the diagonal
    collision.c_i_to_v_00 += inv_mass
    collision.c_i_to_v_11 += inv_mass
    collision.c_i_to_v_22 += inv_mass

    a = collision.c_i_to_v_00
    b = collision.c_i_to_v_01
    c = collision.c_i_to_v_02

    d = collision.c_i_to_v_10
    e = collision.c_i_to_v_11
    f = collision.c_i_to_v_12

    g = collision.c_i_to_v_20
    h = collision.c_i_to_v_21
    i = collision.c_i_to_v_22
    
    # Inverse impulse to velocity
    det =  (a * e) / $Precision * i
    det += (d * h) / $Precision * c
    det += (g * b) / $Precision * f
    det -= (a * h) / $Precision * f
    det -= (g * e) / $Precision * c
    det -= (d * b) / $Precision * i
    det /= $Precision

    collision.v_to_i_00 = (e * i - f * h) / det
    collision.v_to_i_01 = (c * h - b * i) / det
    collision.v_to_i_02 = (b * f - c * e) / det

    collision.v_to_i_10 = (f * g - d * i) / det
    collision.v_to_i_11 = (a * i - c * g) / det
    collision.v_to_i_12 = (c * d - a * f) / det

    collision.v_to_i_20 = (d * h - e * g) / det
    collision.v_to_i_21 = (b * g - a * h) / det
    collision.v_to_i_22 = (a * e - b * d) / det
    
    collision.initialized = collision_frame
end

function handle_collision_impulse()
    define name collider1 = "collider_$(collider1)"
    define name collider2 = "collider_$(collider2)"
    define name collision = "collision_$(collision)"
    
    /scoreboard players set Global twobody $(collider2)
    
    unless collision.initialized == collision_frame
        initialize_collision_matrices() with macros
    end
    
    # Transform by the ct transpose matrix to get the closing velocity in contact coordinates
    c_vel_x = (collision.ct_00 * collision.vel_x + collision.ct_10 * collision.vel_y + collision.ct_20 * collision.vel_z + $Half) / $Precision
    c_vel_y = (collision.ct_01 * collision.vel_x + collision.ct_11 * collision.vel_y + collision.ct_21 * collision.vel_z + $Half) / $Precision
    c_vel_z = (collision.ct_02 * collision.vel_x + collision.ct_12 * collision.vel_y + collision.ct_22 * collision.vel_z + $Half) / $Precision
    
    $Restitution = 600
    restitution = $Restitution
    if c_vel_y > $CancelRestitution
        restitution = 0
    end
    
    desired_vx = 0
    # TODO: Add gravity in the positive Y world direction
    desired_vy = (-(c_vel_y) * restitution) / $Precision
    desired_vz = 0

    desired_dvx = desired_vx - c_vel_x
    desired_dvy = desired_vy - c_vel_y
    desired_dvz = desired_vz - c_vel_z
    
    cix = (collision.v_to_i_00 * desired_dvx + collision.v_to_i_01 * desired_dvy + collision.v_to_i_02 * desired_dvz + $Half) / $Precision
    ciy = (collision.v_to_i_10 * desired_dvx + collision.v_to_i_11 * desired_dvy + collision.v_to_i_12 * desired_dvz + $Half) / $Precision
    ciz = (collision.v_to_i_20 * desired_dvx + collision.v_to_i_21 * desired_dvy + collision.v_to_i_22 * desired_dvz + $Half) / $Precision
    
    planar_impulse = sqrt(cix*cix + ciz*ciz)
    
    $Friction = 800
    max_fric_impulse = (ciy * $Friction + $Half) / $Precision
    
    if planar_impulse > max_fric_impulse
        dir_ix = cix * $Precision / planar_impulse
        dir_iz = ciz * $Precision / planar_impulse
    
        v_per_i_y = collision.c_i_to_v_11 + ((collision.c_i_to_v_10 * dir_ix + collision.c_i_to_v_12 * dir_iz + $Half) / $Precision * $Friction + $Half) / $Precision
        
        ciy = desired_dvy * $Precision / v_per_i_y
        
        cix = ((dir_ix * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
        ciz = ((dir_iz * $Friction + $Half) / $Precision * ciy + $Half) / $Precision
    end
    
    # Transform impulse vector out of contact coordinates
    ix = (collision.ct_00 * cix + collision.ct_01 * ciy + collision.ct_02 * ciz + $Half) / $Precision
    iy = (collision.ct_10 * cix + collision.ct_11 * ciy + collision.ct_12 * ciz + $Half) / $Precision
    iz = (collision.ct_20 * cix + collision.ct_21 * ciy + collision.ct_22 * ciz + $Half) / $Precision
    
    # collider1.id isn't using define name
    with
        $(collider) = collider1.id
    collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    
    if twobody
        ix *= -1
        iy *= -1
        iz *= -1
        
        with
            $(collider) = collider2.id
        collider_apply_impulse(collision.x, collision.y, collision.z, ix, iy, iz)
    end
end